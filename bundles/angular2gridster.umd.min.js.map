{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://angular2gridster/lib/utils/utils.ts","ng://angular2gridster/lib/gridList/gridList.ts","ng://angular2gridster/lib/gridster.service.ts","ng://angular2gridster/lib/gridster-prototype/gridster-prototype.service.ts","ng://angular2gridster/lib/GridsterOptions.ts","ng://angular2gridster/lib/gridster.component.ts","ng://angular2gridster/lib/gridList/GridListItem.ts","ng://angular2gridster/lib/utils/DraggableEvent.ts","ng://angular2gridster/lib/utils/draggable.ts","ng://angular2gridster/lib/gridster-item/gridster-item.component.ts","ng://angular2gridster/lib/gridster-prototype/gridster-item-prototype.directive.ts","ng://angular2gridster/lib/gridster.module.ts"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__decorate","decorators","target","key","desc","d","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","e","ar","push","error","__spread","concat","utils","$element","position","style","left","x","top","y","translate","document","empty","window","getSelection","removeAllRanges","element","containerEl","containerRect","getBoundingClientRect","elRect","right","bottom","elWidth","elHeight","event","pageX","pageY","styleObj","getComputedStyle","parseFloat","getPropertyValue","parentElement","parentElementRect","elementRect","node","regex","parents","_node","ps","parentNode","prop","scroll","test","overflow","HTMLElement","SVGElement","scrollingElement","documentElement","scrollParent","makeGridCol","lanes","result","GridList","items","options","adjustSizeOfItems","generateGrid","toString","item","j","widthOfGrid","grid","output","border","padNumber","indexOf","setOption","name","resetGrid","markItemPositionToGrid","resizeGrid","currentColumn","sortItemsByPosition","getItemPosition","updateItemPosition","findPositionForItem","Math","max","pullItemsToLeft","start","fixedRow","undefined","itemFitsAtPosition","newCol","newRow","moveAndResize","newPosition","size","w","h","width","height","updateItemSize","resolveCollisions","moveItemToPosition","resizeItem","getChangedItems","initialItems","breakpoint","map","changes","oldValues","initItem","find","initItm","isNew","oldX","getValueX","oldY","getValueY","getValueW","getValueH","filter","itemChange","tryToResolveCollisionsLocally","floating","getItemsCollidingWithItem","pushCollidingItems","fixedItem","_this","isItemFloating","forEach","direction","fixedPosition","dragAndDrop","findLeftMostPositionForItem","isOverFixedArea","itemData","checkItemAboveEmptyArea","itemPrototype","checkItemsInArea","fixItemsPositions","validItems","itemComponent","isItemValidForGrid","invalidItems","gridList","copyForBreakpoint","itemCopy","setItemPosition","itm","cachedItem","cachedItm","setValueX","setValueY","setValueW","setValueH","autoSize","deleteItemPositionFromGrid","isDragging","slice","reduce","isFloating","cellItem","min","findDefaultPositionHorizontal","_b","_c","col","colIdx","rowIdx","findDefaultPositionVertical","row","rowStart","rowEnd","colStart","colEnd","sort","item1","item2","position1","position2","ensureColumns","N","collidingItems","itemsAreColliding","leftOfItem","rightOfItem","aboveOfItem","belowOfItem","_gridList","copy","collidingItem","collidingPosition","idx","tail","otherItem","otherPosition","findItemByPosition","getItemByAttribute","nr","prefix","GridsterService","_items","_itemsMap","disabledItems","debounceRenderSubject","Subject","itemRemoveSubject","isInit","pipe","debounceTime","subscribe","render","updateCachedItems","isInitialized","registerItem","init","gridsterComponent","draggableOptions","gridsterOptions","updateMaxItemSize","$positionHighlight","removePositionHighlight","initGridList","setTimeout","copyItems","reflowGridster","setReady","applySizeToItems","applyPositionToItems","refreshLines","reflow","calculateCellSize","responsiveSizes","basicOptions","responsiveOptions","removeItem","splice","removeItemFromCache","onResizeStart","currentElement","_maxGridCols","highlightPositionForItem","isResizing","onResizeDrag","newSize","snapItemSizeToGrid","sizeChanged","dragSizeChanged","snapItemPositionToGrid","positionChanged","dragPositionChanged","restoreCachedItems","previousDragPosition","previousDragSize","onResizeStop","onStart","updateGridsterElementData","onDrag","cancel","onDragOut","onStop","cellHeight","calculateCellHeight","cellWidth","widthHeightRatio","calculateCellWidth","heightToFontSizeRatio","_fontSize","increaseGridsterSize","shrink","isCurrentElement","applyPosition","child","firstChild","increaseWidthWith","maxItemWidth","rowHeights","getRowHeights","rowTops","getRowTops","previousHeight","column","contentHeight","variableHeight","lastHeight","rowHeights_1","rowHeights_1_1","rowHeight","canvas","$backgroundGrid","nativeElement","offsetWidth","offsetHeight","canvasContext","getContext","clearRect","lines","visible","always","linesColor","color","linesBgColor","backgroundColor","linesWidth","fillStyle","fillRect","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","closePath","keys","isValidGridItem","maxItemHeight","applySize","itemSize","parseInt","colSize","round","rowSize","generateItemPosition","coords","getPositionToGridster","positionX","positionY","calculateSize","calculatePosition","display","triggerOnChange","triggerChangeX","triggerChangeY","triggerChangeW","triggerChangeH","change","emit","Injectable","GridsterPrototypeService","dragSubject","dragStartSubject","dragStopSubject","observeDropOver","gridster","data","gridsterEl","querySelectorAll","isOverGridster","nestedGridsterEl","tap","onDrop","observeDropOut","onCancel","observeDragOver","over","isOver","isDrop","drop","dragExt","merge","scan","prev","isEnter","isOut","share","dragEnter","createDragEnterObservable","dragOut","createDragOutObservable","dragOver","switchMap","takeUntil","dragItemStart","dragItemStop","updatePrototypePosition","createDragOverObservable","dragIsOver","onOver","onEnter","onOut","el","parentItem","closest","tolerance","GridsterOptions","config","gridsterElement","defaults","responsiveView","responsiveToParent","resizable","useCSSTransforms","breakpointsMap","sm","md","lg","xl","responsiveContainer","extendResponsiveOptions","of","getOptionsByWidth","getElementWidth","fromEvent","responsiveDebounce","distinctUntilChanged","minWidth","curr","innerWidth","clientWidth","body","GridsterComponent","zone","elementRef","gridsterPrototype","optionsChange","EventEmitter","ready","prototypeDrop","prototypeEnter","prototypeOut","isReady","isPrototypeEntered","isDisabled","subscription","Subscription","ngOnInit","classList","add","reload","runOutsideAngular","passive","scrollableContainer","ngAfterContentInit","connectGridsterPrototype","ngOnDestroy","unsubscribe","enableDraggable","disableDraggable","enableResizable","disableResizable","gridsterScrollData","getScrollPositionFromParents","gridsterRect","adjustItemsHeightToContent","scrollableItemElementSelector","scrollEl","querySelector","contentEl","lastElementChild","scrollElDistance","scrollElRect","ceil","disable","itemIdx","enable","scrollTop","scrollLeft","dropOverObservable","publish","dragObservable","setDragContextGridster","parent","connect","enableDragDrop","NgZone","ElementRef","Input","Output","ViewChild","static","HostBinding","Component","selector","template","providers","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","GridListItem","getItem","offsetheight","childHeight","setFromGridsterItem","isItemSet","Error","setFromGridsterItemPrototype","setFromObjectLiteral","itemObject","getXProperty","getYProperty","getWProperty","getHProperty","hasPositions","updateElemenetPosition","pixelHeight","X_PROPERTY_MAP","Y_PROPERTY_MAP","W_PROPERTY_MAP","H_PROPERTY_MAP","BREAKPOINTS","DraggableEvent","touches","touchEvent","setDataFromTouchEvent","mouseEvent","setDataFromMouseEvent","isTouchEvent","pauseEvent","stopPropagation","preventDefault","cancelBubble","returnValue","getRelativeCoordinates","container","pageYOffset","pageXOffset","rect","clientX","clientY","type","touch","changedTouches","Draggable","mousemove","mouseup","handlerClass","scrollEdge","scrollDirection","autoScrollingInterval","mousedown","dragStart","createDragStartObservable","dragMove","createDragMoveObservable","dragStop","createDragStopObservable","fixProblemWithDnDForIE","requestAnimationFrame","callback","cancelAnimationFrame","cafID","clearTimeout","isDragingByHandler","activeElement","blur","startEvent","mm","moveEvent","inRange","take","addTouchActionNone","skip","val","startScroll","removeTouchActionNone","raf","scrollContainer","getScrollContainer","startScrollForContainer","startScrollForWindow","startScrollVerticallyForContainer","startScrollHorizontallyForContainer","getOffset","startAutoScrolling","SCROLL_SPEED","startScrollVerticallyForWindow","startScrollHorizontallyForWindow","innerHeight","nodeOuterHeight","scrollHeight","RegExp","tagName","amount","bind","getScroll","scrollProp","offsetProp","clientHeight","isValidDragHandler","hasElementWithClass","targetEl","toLowerCase","range","abs","className","contains","isTouchDevice","isIEorEdge","navigator","maxTouchPoints","ua","userAgent","msie","substring","rv","edge","GridsterItemComponent","xChange","yChange","xSmChange","ySmChange","xMdChange","yMdChange","xLgChange","yLgChange","xXlChange","yXlChange","wChange","hChange","wSmChange","hSmChange","wMdChange","hMdChange","wLgChange","hLgChange","wXlChange","hXlChange","end","defaultOptions","minHeight","maxWidth","Infinity","maxHeight","defaultWidth","defaultHeight","subscriptions","dragSubscriptions","resizeSubscriptions","preventAnimation","_positionX","_positionY","wSm","hSm","wMd","hMd","wLg","hLg","wXl","hXl","setPositionsOnItem","ngAfterViewInit","lastOffsetHeight_1","readySubscription_1","MutationObserver","mutations","observe","childList","subtree","attributes","characterData","ngOnChanges","rerender","propName","isFirstChange","currentValue","sub","setPositionsForGrid","getResizeHandlers","handler","getResizeDirection","hasResizableHandle","startData","cursorToElementPosition","draggable","getResizableOptions","dragStartSub","run","createResizeStartObject","dragSub","scrollData","resizeElement","scrollDiffX","scrollDiffY","dragStopSub","onEnd","getDraggableOptions","children","resizableOptions","isItemResizable","resizeHandles","findPosition","minX","maxX","minY","maxY","minW","maxW","minH","maxH","actionType","action","remove","match","split","resizeToNorth","resizeToWest","resizeToEast","resizeToSouth","setMinHeight","setMaxHeight","setMinWidth","setMaxWidth","Inject","args","GridsterItemPrototypeDirective","enter","out","variableHeightContainToRow","subscribtions","dragContextGridster","helper","removeChild","relativeContainerCoords","getContainerCoordsToGridster","parentRect","provideDragElement","containerRectange","updateParentElementData","setElementPosition","scrollSub","parentOffset","offsetLeft","offsetTop","pointerEvents","dragElement","cloneNode","appendChild","fixStylesForBodyHelper","fixStylesForRelativeElement","bodyRect","Directive","GridsterModule","forRoot","ngModule","GridsterModule_1","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","\nimport { DraggableEvent } from './DraggableEvent';\n\nexport const utils = {\n    setCssElementPosition: function ($element: HTMLElement, position: {x: number, y: number}) {\n        $element.style.left = position.x + 'px';\n        $element.style.top = position.y + 'px';\n    },\n    resetCSSElementPosition: function ($element: HTMLElement) {\n        $element.style.left = '';\n        $element.style.top = '';\n    },\n    setTransform: function ($element: HTMLElement, position: {x: number, y: number}) {\n        const left = position.x;\n        const top = position.y;\n\n        // Replace unitless items with px\n        const translate = `translate(${left}px,${top}px)`;\n\n        $element.style['transform'] = translate;\n        (<any>$element.style)['WebkitTransform'] = translate;\n        (<any>$element.style)['MozTransform'] = translate;\n        (<any>$element.style)['msTransform'] = translate;\n        (<any>$element.style)['OTransform'] = translate;\n    },\n    resetTransform: function ($element: HTMLElement) {\n        $element.style['transform'] = '';\n        (<any>$element.style)['WebkitTransform'] = '';\n        (<any>$element.style)['MozTransform'] = '';\n        (<any>$element.style)['msTransform'] = '';\n        (<any>$element.style)['OTransform'] = '';\n    },\n    clearSelection: () => {\n        if ((<any>document)['selection']) {\n            (<any>document)['selection'].empty();\n        } else if (window.getSelection) {\n            window.getSelection().removeAllRanges();\n        }\n    },\n    isElementFitContainer: function (element: HTMLElement, containerEl: HTMLElement): boolean {\n        const containerRect = containerEl.getBoundingClientRect();\n        const elRect = element.getBoundingClientRect();\n\n        return elRect.left > containerRect.left &&\n            elRect.right < containerRect.right &&\n            elRect.top > containerRect.top &&\n            elRect.bottom < containerRect.bottom;\n    },\n    isElementIntersectContainer: function (element: HTMLElement, containerEl: HTMLElement): boolean {\n        const containerRect = containerEl.getBoundingClientRect();\n        const elRect = element.getBoundingClientRect();\n\n        const elWidth = elRect.right - elRect.left;\n        const elHeight = elRect.bottom - elRect.top;\n\n        return (elRect.left + (elWidth / 2)) > containerRect.left &&\n            (elRect.right - (elWidth / 2)) < containerRect.right &&\n            (elRect.top + (elHeight / 2)) > containerRect.top &&\n            (elRect.bottom - (elHeight / 2)) < containerRect.bottom;\n    },\n    isElementTouchContainer: function (element: HTMLElement, containerEl: HTMLElement): boolean {\n        const containerRect = containerEl.getBoundingClientRect();\n        const elRect = element.getBoundingClientRect();\n\n        return elRect.right > containerRect.left &&\n            elRect.bottom > containerRect.top &&\n            elRect.left < containerRect.right &&\n            elRect.top < containerRect.bottom;\n    },\n    isCursorAboveElement: function (event: DraggableEvent, element: HTMLElement): boolean {\n        const elRect = element.getBoundingClientRect();\n\n        return event.pageX > elRect.left &&\n            event.pageX < elRect.right &&\n            event.pageY > elRect.top &&\n            event.pageY < elRect.bottom;\n    },\n    getElementOuterHeight: function ($element: HTMLElement) {\n        const styleObj = window.getComputedStyle($element);\n        // NOTE: Manually calculating height because IE's `clientHeight` isn't always\n        // reliable.\n        return parseFloat(styleObj.getPropertyValue('height')) +\n            parseFloat(styleObj.getPropertyValue('padding-top')) +\n            parseFloat(styleObj.getPropertyValue('padding-bottom'));\n    },\n    getRelativeCoordinates: (element: HTMLElement, parentElement: HTMLElement): {top: number, left: number} => {\n        const parentElementRect = parentElement.getBoundingClientRect();\n        const elementRect = element.getBoundingClientRect();\n\n        return {\n            top: elementRect.top - parentElementRect.top,\n            left: elementRect.left - parentElementRect.left\n        };\n    },\n    getScrollableContainer(node) {\n        const regex = /(auto|scroll)/;\n        const parents = (_node, ps) => {\n            if (_node.parentNode === null) {\n                return ps;\n            }\n            return parents(_node.parentNode, ps.concat([_node]));\n        };\n\n        const style = (_node, prop) => {\n            return getComputedStyle(_node, null).getPropertyValue(prop);\n        };\n        const overflow = _node => {\n            return (\n                style(_node, 'overflow') + style(_node, 'overflow-y') + style(_node, 'overflow-x')\n            );\n        };\n        const scroll = _node => regex.test(overflow(_node));\n\n        /* eslint-disable consistent-return */\n        const scrollParent = _node => {\n            if (!(_node instanceof HTMLElement || _node instanceof SVGElement)) {\n                return;\n            }\n\n            const ps = parents(_node.parentNode, []);\n\n            for (let i = 0; i < ps.length; i += 1) {\n                if (scroll(ps[i])) {\n                    return ps[i];\n                }\n            }\n\n            return document.scrollingElement || document.documentElement;\n        };\n\n        return scrollParent(node);\n    }\n};\n","import { GridListItem } from './GridListItem';\nimport { IGridsterOptions } from '../IGridsterOptions';\n\n// const GridCol = function(lanes) {\n//     for (let i = 0; i < lanes; i++) {\n//         this.push(null);\n//     }\n// };\nconst makeGridCol = function (lanes: number): GridCol {\n    let result: GridListItem[] = [];\n    for (let i = 0; i < lanes; i++) {\n        result.push(null);\n    }\n    return result;\n};\n\ntype GridCol = GridListItem[];\n\n/**\n * A GridList manages the two-dimensional positions from a list of items,\n * within a virtual matrix.\n *\n * The GridList's main function is to convert the item positions from one\n * grid size to another, maintaining as much of their order as possible.\n *\n * The GridList's second function is to handle collisions when moving an item\n * over another.\n *\n * The positioning algorithm places items in columns. Starting from left to\n * right, going through each column top to bottom.\n *\n * The size of an item is expressed using the number of cols and rows it\n * takes up within the grid (w and h)\n *\n * The position of an item is express using the col and row position within\n * the grid (x and y)\n *\n * An item is an object of structure:\n * {\n *   w: 3, h: 1,\n *   x: 0, y: 1\n * }\n */\nexport class GridList {\n    items: Array<GridListItem>;\n    grid: Array<Array<GridListItem>>;\n\n    options: IGridsterOptions;\n\n    constructor(items: Array<GridListItem>, options: IGridsterOptions) {\n        this.options = options;\n\n        this.items = items;\n\n        this.adjustSizeOfItems();\n\n        this.generateGrid();\n    }\n\n    /**\n     * Illustrates grid as text-based table, using a number identifier for each\n     * item. E.g.\n     *\n     *  #|  0  1  2  3  4  5  6  7  8  9 10 11 12 13\n     *  --------------------------------------------\n     *  0| 00 02 03 04 04 06 08 08 08 12 12 13 14 16\n     *  1| 01 -- 03 05 05 07 09 10 11 11 -- 13 15 --\n     *\n     * Warn: Does not work if items don't have a width or height specified\n     * besides their position in the grid.\n     */\n    toString() {\n        const widthOfGrid = this.grid.length;\n        let output = '\\n #|',\n            border = '\\n --',\n            item,\n            i,\n            j;\n\n        // Render the table header\n        for (i = 0; i < widthOfGrid; i++) {\n            output += ' ' + this.padNumber(i, ' ');\n            border += '---';\n        }\n        output += border;\n\n        // Render table contents row by row, as we go on the y axis\n        for (i = 0; i < this.options.lanes; i++) {\n            output += '\\n' + this.padNumber(i, ' ') + '|';\n            for (j = 0; j < widthOfGrid; j++) {\n                output += ' ';\n                item = this.grid[j][i];\n                output += item\n                    ? this.padNumber(this.items.indexOf(item), '0')\n                    : '--';\n            }\n        }\n        output += '\\n';\n        return output;\n    }\n\n    setOption(name: keyof IGridsterOptions, value: any) {\n        (<any>this.options[name]) = value;\n    }\n\n    /**\n     * Build the grid structure from scratch, with the current item positions\n     */\n    generateGrid() {\n        let i;\n        this.resetGrid();\n        for (i = 0; i < this.items.length; i++) {\n            this.markItemPositionToGrid(this.items[i]);\n        }\n    }\n\n    resizeGrid(lanes: number) {\n        let currentColumn = 0;\n\n        this.options.lanes = lanes;\n        this.adjustSizeOfItems();\n\n        this.sortItemsByPosition();\n        this.resetGrid();\n\n        // The items will be sorted based on their index within the this.items array,\n        // that is their \"1d position\"\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i],\n                position = this.getItemPosition(item);\n\n            this.updateItemPosition(\n                item,\n                this.findPositionForItem(item, { x: currentColumn, y: 0 })\n            );\n\n            // New items should never be placed to the left of previous items\n            currentColumn = Math.max(currentColumn, position.x);\n        }\n\n        this.pullItemsToLeft();\n    }\n\n    /**\n     * This method has two options for the position we want for the item:\n     * - Starting from a certain row/column number and only looking for\n     *   positions to its right\n     * - Accepting positions for a certain row number only (use-case: items\n     *   being shifted to the left/right as a result of collisions)\n     *\n     * @param Object item\n     * @param Object start Position from which to start\n     *     the search.\n     * @param number [fixedRow] If provided, we're going to try to find a\n     *     position for the new item on it. If doesn't fit there, we're going\n     *     to put it on the first row.\n     *\n     * @returns Array x and y.\n     */\n    findPositionForItem(\n        item: GridListItem,\n        start: { x: number; y: number },\n        fixedRow?: number\n    ): [number, number] {\n        let x, y, position;\n\n        // Start searching for a position from the horizontal position of the\n        // rightmost item from the grid\n        for (x = start.x; x < this.grid.length; x++) {\n            if (fixedRow !== undefined) {\n                position = [x, fixedRow];\n\n                if (this.itemFitsAtPosition(item, position)) {\n                    return position;\n                }\n            } else {\n                for (y = start.y; y < this.options.lanes; y++) {\n                    position = [x, y];\n\n                    if (this.itemFitsAtPosition(item, position)) {\n                        return position;\n                    }\n                }\n            }\n        }\n\n        // If we've reached this point, we need to start a new column\n        const newCol = this.grid.length;\n        let newRow = 0;\n\n        if (\n            fixedRow !== undefined &&\n            this.itemFitsAtPosition(item, [newCol, fixedRow])\n        ) {\n            newRow = fixedRow;\n        }\n\n        return [newCol, newRow];\n    }\n\n    moveAndResize(\n        item: GridListItem,\n        newPosition: Array<number>,\n        size: { w: number; h: number }\n    ) {\n        const position = this.getItemPosition({\n            x: newPosition[0],\n            y: newPosition[1],\n            w: item.w,\n            h: item.h\n        });\n        const width = size.w || item.w,\n            height = size.h || item.h;\n\n        this.updateItemPosition(item, [position.x, position.y]);\n        this.updateItemSize(item, width, height);\n\n        this.resolveCollisions(item);\n    }\n\n    moveItemToPosition(item: GridListItem, newPosition: Array<number>) {\n        const position = this.getItemPosition({\n            x: newPosition[0],\n            y: newPosition[1],\n            w: item.w,\n            h: item.h\n        });\n\n        this.updateItemPosition(item, [position.x, position.y]);\n        this.resolveCollisions(item);\n    }\n\n    /**\n     * Resize an item and resolve collisions.\n     *\n     * @param Object item A reference to an item that's part of the grid.\n     * @param Object size\n     * @param number [size.w=item.w] The new width.\n     * @param number [size.h=item.h] The new height.\n     */\n    resizeItem(item: GridListItem, size: { w: number; h: number }) {\n        const width = size.w || item.w,\n            height = size.h || item.h;\n\n        this.updateItemSize(item, width, height);\n\n        this.pullItemsToLeft(item);\n    }\n\n    /**\n     * Compare the current items against a previous snapshot and return only\n     * the ones that changed their attributes in the meantime. This includes both\n     * position (x, y) and size (w, h)\n     *\n     * Each item that is returned is not the GridListItem but the helper that holds GridListItem\n     * and list of changed properties.\n     */\n    getChangedItems(\n        initialItems: Array<GridListItem>,\n        breakpoint?: string\n    ): Array<{\n        item: GridListItem;\n        changes: Array<string>;\n        isNew: boolean;\n    }> {\n        return this.items\n            .map((item: GridListItem) => {\n                const changes = [];\n                const oldValues: {\n                    x?: number;\n                    y?: number;\n                    w?: number;\n                    h?: number;\n                } = {};\n                const initItem = initialItems.find(\n                    initItm => initItm.$element === item.$element\n                );\n\n                if (!initItem) {\n                    return { item, changes: ['x', 'y', 'w', 'h'], isNew: true };\n                }\n\n                const oldX = initItem.getValueX(breakpoint);\n                if (item.getValueX(breakpoint) !== oldX) {\n                    changes.push('x');\n                    if (oldX || oldX === 0) {\n                        oldValues.x = oldX;\n                    }\n                }\n\n                const oldY = initItem.getValueY(breakpoint);\n                if (item.getValueY(breakpoint) !== oldY) {\n                    changes.push('y');\n                    if (oldY || oldY === 0) {\n                        oldValues.y = oldY;\n                    }\n                }\n                if (\n                    item.getValueW(breakpoint) !==\n                    initItem.getValueW(breakpoint)\n                ) {\n                    changes.push('w');\n                    oldValues.w = initItem.w;\n                }\n                if (\n                    item.getValueH(breakpoint) !==\n                    initItem.getValueH(breakpoint)\n                ) {\n                    changes.push('h');\n                    oldValues.h = initItem.h;\n                }\n\n                return { item, oldValues, changes, isNew: false };\n            })\n            .filter(\n                (itemChange: {\n                    item: GridListItem;\n                    changes: Array<string>;\n                }) => {\n                    return itemChange.changes.length;\n                }\n            );\n    }\n\n    resolveCollisions(item: GridListItem) {\n        if (!this.tryToResolveCollisionsLocally(item)) {\n            this.pullItemsToLeft(item);\n        }\n        if (this.options.floating) {\n            this.pullItemsToLeft();\n        } else if (this.getItemsCollidingWithItem(item).length) {\n            this.pullItemsToLeft();\n        }\n    }\n\n    pushCollidingItems(fixedItem?: GridListItem) {\n        // Start a fresh grid with the fixed item already placed inside\n        this.sortItemsByPosition();\n        this.resetGrid();\n        this.generateGrid();\n\n        this.items\n            .filter(item => !this.isItemFloating(item) && item !== fixedItem)\n            .forEach(item => {\n                if (!this.tryToResolveCollisionsLocally(item)) {\n                    this.pullItemsToLeft(item);\n                }\n            });\n    }\n\n    /**\n     * Build the grid from scratch, by using the current item positions and\n     * pulling them as much to the left as possible, removing as space between\n     * them as possible.\n     *\n     * If a \"fixed item\" is provided, its position will be kept intact and the\n     * rest of the items will be layed around it.\n     */\n    pullItemsToLeft(fixedItem?: any) {\n        if (this.options.direction === 'none') {\n            return;\n        }\n\n        // Start a fresh grid with the fixed item already placed inside\n        this.sortItemsByPosition();\n        this.resetGrid();\n\n        // Start the grid with the fixed item as the first positioned item\n        if (fixedItem) {\n            const fixedPosition = this.getItemPosition(fixedItem);\n            this.updateItemPosition(fixedItem, [\n                fixedPosition.x,\n                fixedPosition.y\n            ]);\n        }\n\n        this.items\n            .filter((item: GridListItem) => {\n                return !item.dragAndDrop && item !== fixedItem;\n            })\n            .forEach((item: GridListItem) => {\n                const fixedPosition = this.getItemPosition(item);\n                this.updateItemPosition(item, [\n                    fixedPosition.x,\n                    fixedPosition.y\n                ]);\n            });\n\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i],\n                position = this.getItemPosition(item);\n\n            // The fixed item keeps its exact position\n            if (\n                (fixedItem && item === fixedItem) ||\n                !item.dragAndDrop ||\n                (!this.options.floating &&\n                    this.isItemFloating(item) &&\n                    !this.getItemsCollidingWithItem(item).length)\n            ) {\n                continue;\n            }\n\n            const x = this.findLeftMostPositionForItem(item),\n                newPosition = this.findPositionForItem(\n                    item,\n                    { x: x, y: 0 },\n                    position.y\n                );\n\n            this.updateItemPosition(item, newPosition);\n        }\n    }\n\n    isOverFixedArea(\n        x: number,\n        y: number,\n        w: number,\n        h: number,\n        item: GridListItem = null\n    ): boolean {\n        let itemData = { x, y, w, h };\n\n        if (this.options.direction !== 'horizontal') {\n            itemData = { x: y, y: x, w: h, h: w };\n        }\n\n        for (let i = itemData.x; i < itemData.x + itemData.w; i++) {\n            for (let j = itemData.y; j < itemData.y + itemData.h; j++) {\n                if (\n                    this.grid[i] &&\n                    this.grid[i][j] &&\n                    this.grid[i][j] !== item &&\n                    !this.grid[i][j].dragAndDrop\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    checkItemAboveEmptyArea(\n        item: GridListItem,\n        newPosition: { x: number; y: number }\n    ) {\n        let itemData = {\n            x: newPosition.x,\n            y: newPosition.y,\n            w: item.w,\n            h: item.h\n        };\n        if (\n            !item.itemPrototype &&\n            item.x === newPosition.x &&\n            item.y === newPosition.y\n        ) {\n            return true;\n        }\n\n        if (this.options.direction === 'horizontal') {\n            itemData = {\n                x: newPosition.y,\n                y: newPosition.x,\n                w: itemData.h,\n                h: itemData.w\n            };\n        }\n        return !this.checkItemsInArea(\n            itemData.y,\n            itemData.y + itemData.h - 1,\n            itemData.x,\n            itemData.x + itemData.w - 1,\n            item\n        );\n    }\n\n    fixItemsPositions(options: IGridsterOptions) {\n        // items with x, y that fits gird with size of options.lanes\n        const validItems = this.items\n            .filter((item: GridListItem) => item.itemComponent)\n            .filter((item: GridListItem) =>\n                this.isItemValidForGrid(item, options)\n            );\n        // items that x, y must be generated\n        const invalidItems = this.items\n            .filter((item: GridListItem) => item.itemComponent)\n            .filter(\n                (item: GridListItem) => !this.isItemValidForGrid(item, options)\n            );\n\n        const gridList = new GridList([], options);\n\n        // put items with defined positions to the grid\n        gridList.items = validItems.map((item: GridListItem) => {\n            return item.copyForBreakpoint(options.breakpoint);\n        });\n\n        gridList.generateGrid();\n\n        invalidItems.forEach(item => {\n            // TODO: check if this change does not broke anything\n            // const itemCopy = item.copy();\n            const itemCopy = item.copyForBreakpoint(options.breakpoint);\n            const position = gridList.findPositionForItem(itemCopy, {\n                x: 0,\n                y: 0\n            });\n\n            gridList.items.push(itemCopy);\n            gridList.setItemPosition(itemCopy, position);\n            gridList.markItemPositionToGrid(itemCopy);\n        });\n\n        gridList.pullItemsToLeft();\n        gridList.pushCollidingItems();\n\n        this.items.forEach((itm: GridListItem) => {\n            const cachedItem = gridList.items.filter(cachedItm => {\n                return cachedItm.$element === itm.$element;\n            })[0];\n\n            itm.setValueX(cachedItem.x, options.breakpoint);\n            itm.setValueY(cachedItem.y, options.breakpoint);\n            itm.setValueW(cachedItem.w, options.breakpoint);\n            itm.setValueH(cachedItem.h, options.breakpoint);\n            itm.autoSize = cachedItem.autoSize;\n        });\n    }\n\n    deleteItemPositionFromGrid(item: GridListItem) {\n        const position = this.getItemPosition(item);\n        let x, y;\n\n        for (x = position.x; x < position.x + position.w; x++) {\n            // It can happen to try to remove an item from a position not generated\n            // in the grid, probably when loading a persisted grid of items. No need\n            // to create a column to be able to remove something from it, though\n            if (!this.grid[x]) {\n                continue;\n            }\n\n            for (y = position.y; y < position.y + position.h; y++) {\n                // Don't clear the cell if it's been occupied by a different widget in\n                // the meantime (e.g. when an item has been moved over this one, and\n                // thus by continuing to clear this item's previous position you would\n                // cancel the first item's move, leaving it without any position even)\n                if (this.grid[x][y] === item) {\n                    this.grid[x][y] = null;\n                }\n            }\n        }\n    }\n\n    private isItemFloating(item: any) {\n        if (item.itemComponent && item.itemComponent.isDragging) {\n            return false;\n        }\n        const position = this.getItemPosition(item);\n\n        if (position.x === 0) {\n            return false;\n        }\n        const rowBelowItem = this.grid[position.x - 1];\n\n        return (rowBelowItem || [])\n            .slice(position.y, position.y + position.h)\n            .reduce((isFloating, cellItem) => {\n                return isFloating && !cellItem;\n            }, true);\n    }\n\n    private isItemValidForGrid(item: GridListItem, options: IGridsterOptions) {\n        const itemData =\n            options.direction === 'horizontal'\n                ? {\n                      x: item.getValueY(options.breakpoint),\n                      y: item.getValueX(options.breakpoint),\n                      w: item.getValueH(options.breakpoint),\n                      h: Math.min(\n                          item.getValueW(this.options.breakpoint),\n                          options.lanes\n                      )\n                  }\n                : {\n                      x: item.getValueX(options.breakpoint),\n                      y: item.getValueY(options.breakpoint),\n                      w: Math.min(\n                          item.getValueW(this.options.breakpoint),\n                          options.lanes\n                      ),\n                      h: item.getValueH(options.breakpoint)\n                  };\n\n        return (\n            typeof itemData.x === 'number' &&\n            typeof itemData.y === 'number' &&\n            itemData.x + itemData.w <= options.lanes\n        );\n    }\n\n    public findDefaultPositionHorizontal(width: number, height: number) {\n        for (const col of this.grid) {\n            const colIdx = this.grid.indexOf(col);\n            let rowIdx = 0;\n            while (rowIdx < col.length - height + 1) {\n                if (\n                    !this.checkItemsInArea(\n                        colIdx,\n                        colIdx + width - 1,\n                        rowIdx,\n                        rowIdx + height - 1\n                    )\n                ) {\n                    return [colIdx, rowIdx];\n                }\n                rowIdx++;\n            }\n        }\n        return [this.grid.length, 0];\n    }\n\n    public findDefaultPositionVertical(width: number, height: number) {\n        for (const row of this.grid) {\n            const rowIdx = this.grid.indexOf(row);\n            let colIdx = 0;\n            while (colIdx < row.length - width + 1) {\n                if (\n                    !this.checkItemsInArea(\n                        rowIdx,\n                        rowIdx + height - 1,\n                        colIdx,\n                        colIdx + width - 1\n                    )\n                ) {\n                    return [colIdx, rowIdx];\n                }\n                colIdx++;\n            }\n        }\n        return [0, this.grid.length];\n    }\n\n    private checkItemsInArea(\n        rowStart: number,\n        rowEnd: number,\n        colStart: number,\n        colEnd: number,\n        item?: GridListItem\n    ) {\n        for (let i = rowStart; i <= rowEnd; i++) {\n            for (let j = colStart; j <= colEnd; j++) {\n                if (\n                    this.grid[i] &&\n                    this.grid[i][j] &&\n                    (item ? this.grid[i][j] !== item : true)\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private sortItemsByPosition() {\n        this.items.sort((item1, item2) => {\n            const position1 = this.getItemPosition(item1),\n                position2 = this.getItemPosition(item2);\n\n            // Try to preserve columns.\n            if (position1.x !== position2.x) {\n                return position1.x - position2.x;\n            }\n\n            if (position1.y !== position2.y) {\n                return position1.y - position2.y;\n            }\n\n            // The items are placed on the same position.\n            return 0;\n        });\n    }\n\n    /**\n     * Some items can have 100% height or 100% width. Those dimmensions are\n     * expressed as 0. We need to ensure a valid width and height for each of\n     * those items as the number of items per lane.\n     */\n    private adjustSizeOfItems() {\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i];\n\n            // This can happen only the first time items are checked.\n            // We need the property to have a value for all the items so that the\n            // `cloneItems` method will merge the properties properly. If we only set\n            // it to the items that need it then the following can happen:\n            //\n            // cloneItems([{id: 1, autoSize: true}, {id: 2}],\n            //            [{id: 2}, {id: 1, autoSize: true}]);\n            //\n            // will result in\n            //\n            // [{id: 1, autoSize: true}, {id: 2, autoSize: true}]\n            if (item.autoSize === undefined) {\n                item.autoSize = item.w === 0 || item.h === 0;\n            }\n\n            if (item.autoSize) {\n                if (this.options.direction === 'horizontal') {\n                    item.h = this.options.lanes;\n                } else {\n                    item.w = this.options.lanes;\n                }\n            }\n        }\n    }\n\n    private resetGrid() {\n        this.grid = [];\n    }\n\n    /**\n     * Check that an item wouldn't overlap with another one if placed at a\n     * certain position within the grid\n     */\n    private itemFitsAtPosition(item: GridListItem, newPosition: [number, number]) {\n        const position = this.getItemPosition(item);\n        let x, y;\n\n        // No coordonate can be negative\n        if (newPosition[0] < 0 || newPosition[1] < 0) {\n            return false;\n        }\n\n        // Make sure the item isn't larger than the entire grid\n        if (\n            newPosition[1] + Math.min(position.h, this.options.lanes) >\n            this.options.lanes\n        ) {\n            return false;\n        }\n\n        if (this.isOverFixedArea(item.x, item.y, item.w, item.h)) {\n            return false;\n        }\n\n        // Make sure the position doesn't overlap with an already positioned\n        // item.\n        for (x = newPosition[0]; x < newPosition[0] + position.w; x++) {\n            const col = this.grid[x];\n            // Surely a column that hasn't even been created yet is available\n            if (!col) {\n                continue;\n            }\n\n            for (y = newPosition[1]; y < newPosition[1] + position.h; y++) {\n                // Any space occupied by an item can continue to be occupied by the\n                // same item.\n                if (col[y] && col[y] !== item) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private updateItemPosition(item: GridListItem, position: [number, number]) {\n        if (item.x !== null && item.y !== null) {\n            this.deleteItemPositionFromGrid(item);\n        }\n\n        this.setItemPosition(item, position);\n\n        this.markItemPositionToGrid(item);\n    }\n\n    /**\n     * @param Object item A reference to a grid item.\n     * @param number width The new width.\n     * @param number height The new height.\n     */\n    private updateItemSize(item: GridListItem, width: number, height: number) {\n        if (item.x !== null && item.y !== null) {\n            this.deleteItemPositionFromGrid(item);\n        }\n\n        item.w = width;\n        item.h = height;\n\n        this.markItemPositionToGrid(item);\n    }\n\n    /**\n     * Mark the grid cells that are occupied by an item. This prevents items\n     * from overlapping in the grid\n     */\n    private markItemPositionToGrid(item: GridListItem) {\n        const position = this.getItemPosition(item);\n        let x, y;\n\n        // Ensure that the grid has enough columns to accomodate the current item.\n        this.ensureColumns(position.x + position.w);\n\n        for (x = position.x; x < position.x + position.w; x++) {\n            for (y = position.y; y < position.y + position.h; y++) {\n                this.grid[x][y] = item;\n            }\n        }\n    }\n\n    /**\n     * Ensure that the grid has at least N columns available.\n     */\n    private ensureColumns(N: number) {\n        for (let i = 0; i < N; i++) {\n            if (!this.grid[i]) {\n                this.grid.push(makeGridCol(this.options.lanes));\n            }\n        }\n    }\n\n    private getItemsCollidingWithItem(item: GridListItem): number[] {\n        const collidingItems = [];\n        for (let i = 0; i < this.items.length; i++) {\n            if (\n                item !== this.items[i] &&\n                this.itemsAreColliding(item, this.items[i])\n            ) {\n                collidingItems.push(i);\n            }\n        }\n        return collidingItems;\n    }\n\n    private itemsAreColliding(item1: GridListItem, item2: GridListItem) {\n        const position1 = this.getItemPosition(item1),\n            position2 = this.getItemPosition(item2);\n\n        return !(\n            position2.x >= position1.x + position1.w ||\n            position2.x + position2.w <= position1.x ||\n            position2.y >= position1.y + position1.h ||\n            position2.y + position2.h <= position1.y\n        );\n    }\n\n    /**\n     * Attempt to resolve the collisions after moving an item over one or more\n     * other items within the grid, by shifting the position of the colliding\n     * items around the moving one. This might result in subsequent collisions,\n     * in which case we will revert all position permutations. To be able to\n     * revert to the initial item positions, we create a virtual grid in the\n     * process\n     */\n    private tryToResolveCollisionsLocally(item: GridListItem) {\n        const collidingItems = this.getItemsCollidingWithItem(item);\n        if (!collidingItems.length) {\n            return true;\n        }\n\n        const _gridList = new GridList(\n            this.items.map(itm => {\n                return itm.copy();\n            }),\n            this.options\n        );\n\n        let leftOfItem: [number, number];\n        let rightOfItem: [number, number];\n        let aboveOfItem: [number, number];\n        let belowOfItem: [number, number];\n\n        for (let i = 0; i < collidingItems.length; i++) {\n            const collidingItem = _gridList.items[collidingItems[i]],\n                collidingPosition = this.getItemPosition(collidingItem);\n\n            // We use a simple algorithm for moving items around when collisions occur:\n            // In this prioritized order, we try to move a colliding item around the\n            // moving one:\n            // 1. to its left side\n            // 2. above it\n            // 3. under it\n            // 4. to its right side\n            const position = this.getItemPosition(item);\n\n            leftOfItem = [\n                position.x - collidingPosition.w,\n                collidingPosition.y\n            ];\n            rightOfItem = [position.x + position.w, collidingPosition.y];\n            aboveOfItem = [\n                collidingPosition.x,\n                position.y - collidingPosition.h\n            ];\n            belowOfItem = [collidingPosition.x, position.y + position.h];\n\n            if (_gridList.itemFitsAtPosition(collidingItem, leftOfItem)) {\n                _gridList.updateItemPosition(collidingItem, leftOfItem);\n            } else if (\n                _gridList.itemFitsAtPosition(collidingItem, aboveOfItem)\n            ) {\n                _gridList.updateItemPosition(collidingItem, aboveOfItem);\n            } else if (\n                _gridList.itemFitsAtPosition(collidingItem, belowOfItem)\n            ) {\n                _gridList.updateItemPosition(collidingItem, belowOfItem);\n            } else if (\n                _gridList.itemFitsAtPosition(collidingItem, rightOfItem)\n            ) {\n                _gridList.updateItemPosition(collidingItem, rightOfItem);\n            } else {\n                // Collisions failed, we must use the pullItemsToLeft method to arrange\n                // the other items around this item with fixed position. This is our\n                // plan B for when local collision resolving fails.\n                return false;\n            }\n        }\n        // If we reached this point it means we managed to resolve the collisions\n        // from one single iteration, just by moving the colliding items around. So\n        // we accept this scenario and merge the branched-out grid instance into the\n        // original one\n\n        this.items.forEach((itm: GridListItem, idx: number) => {\n            const cachedItem = _gridList.items.filter(cachedItm => {\n                return cachedItm.$element === itm.$element;\n            })[0];\n\n            itm.x = cachedItem.x;\n            itm.y = cachedItem.y;\n            itm.w = cachedItem.w;\n            itm.h = cachedItem.h;\n            itm.autoSize = cachedItem.autoSize;\n        });\n        this.generateGrid();\n        return true;\n    }\n\n    /**\n     * When pulling items to the left, we need to find the leftmost position for\n     * an item, with two considerations in mind:\n     * - preserving its current row\n     * - preserving the previous horizontal order between items\n     */\n    private findLeftMostPositionForItem(item: any) {\n        let tail = 0;\n        const position = this.getItemPosition(item);\n\n        for (let i = 0; i < this.grid.length; i++) {\n            for (let j = position.y; j < position.y + position.h; j++) {\n                const otherItem = this.grid[i][j];\n\n                if (!otherItem) {\n                    continue;\n                }\n\n                const otherPosition = this.getItemPosition(otherItem);\n\n                if (this.items.indexOf(otherItem) < this.items.indexOf(item)) {\n                    tail = otherPosition.x + otherPosition.w;\n                }\n            }\n        }\n\n        return tail;\n    }\n\n    public findItemByPosition(x: number, y: number): GridListItem {\n        for (let i = 0; i < this.items.length; i++) {\n            if (this.items[i].x === x && this.items[i].y === y) {\n                return this.items[i];\n            }\n        }\n    }\n\n    public getItemByAttribute(key: keyof GridListItem, value: any) {\n        for (let i = 0; i < this.items.length; i++) {\n            if (this.items[i][key] === value) {\n                return this.items[i];\n            }\n        }\n        return null;\n    }\n\n    private padNumber(nr: number, prefix: string) {\n        // Currently works for 2-digit numbers (<100)\n        return nr >= 10 ? nr : prefix + nr;\n    }\n\n    /**\n     * If the direction is vertical we need to rotate the grid 90 deg to the\n     * left. Thus, we simulate the fact that items are being pulled to the top.\n     *\n     * Since the items have widths and heights, if we apply the classic\n     * counter-clockwise 90 deg rotation\n     *\n     *     [0 -1]\n     *     [1  0]\n     *\n     * then the top left point of an item will become the bottom left point of\n     * the rotated item. To adjust for this, we need to subtract from the y\n     * position the height of the original item - the width of the rotated item.\n     *\n     * However, if we do this then we'll reverse some actions: resizing the\n     * width of an item will stretch the item to the left instead of to the\n     * right; resizing an item that doesn't fit into the grid will push the\n     * items around it instead of going on a new row, etc.\n     *\n     * We found it better to do a vertical flip of the grid after rotating it.\n     * This restores the direction of the actions and greatly simplifies the\n     * transformations.\n     */\n    private getItemPosition(item: any): { x: number, y: number, w: number, h: number } {\n        if (this.options.direction === 'horizontal') {\n            return item;\n        } else {\n            return {\n                x: item.y,\n                y: item.x,\n                w: item.h,\n                h: item.w\n            };\n        }\n    }\n\n    /**\n     * See getItemPosition.\n     */\n    private setItemPosition(item: any, position: [number, number]) {\n        if (this.options.direction === 'horizontal') {\n            item.x = position[0];\n            item.y = position[1];\n        } else {\n            // We're supposed to subtract the rotated item's height which is actually\n            // the non-rotated item's width.\n            item.x = position[1];\n            item.y = position[0];\n        }\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\nimport { GridList } from './gridList/gridList';\nimport { IGridsterOptions } from './IGridsterOptions';\nimport { IGridsterDraggableOptions } from './IGridsterDraggableOptions';\nimport { GridListItem } from './gridList/GridListItem';\nimport { GridsterComponent } from './gridster.component';\nimport { GridsterOptions } from './GridsterOptions';\n\n@Injectable()\nexport class GridsterService {\n    $element: HTMLElement;\n\n    gridList: GridList;\n\n    items: Array<GridListItem> = [];\n    _items: Array<GridListItem> = [];\n    _itemsMap: { [breakpoint: string]: Array<GridListItem> } = {};\n    disabledItems: Array<GridListItem> = [];\n\n    options: IGridsterOptions;\n    draggableOptions: IGridsterDraggableOptions;\n\n    gridsterRect: ClientRect;\n    gridsterScrollData: { scrollTop: number, scrollLeft: number };\n\n    gridsterOptions: GridsterOptions;\n\n    gridsterComponent: GridsterComponent;\n\n    debounceRenderSubject = new Subject();\n\n    public $positionHighlight: HTMLElement;\n\n    public maxItemWidth: number;\n    public maxItemHeight: number;\n\n    public cellWidth: number;\n    public cellHeight: number;\n\n    public itemRemoveSubject: Subject<GridListItem> = new Subject();\n\n    private _fontSize: number;\n\n    private previousDragPosition: Array<number>;\n    private previousDragSize: Array<number>;\n\n    private currentElement: HTMLElement;\n\n    private _maxGridCols: number;\n\n    private isInit = false;\n\n    constructor() {\n        this.itemRemoveSubject.pipe(debounceTime(0)).subscribe(() => {\n            this.gridList.pullItemsToLeft();\n            this.render();\n            this.updateCachedItems();\n        });\n\n        this.debounceRenderSubject.pipe(debounceTime(0)).subscribe(() => this.render());\n    }\n\n    isInitialized(): boolean {\n        return this.isInit;\n    }\n\n    /**\n     * Must be called before init\n     * @param item\n     */\n    registerItem(item: GridListItem) {\n\n        this.items.push(item);\n        return item;\n    }\n\n    init(gridsterComponent: GridsterComponent) {\n\n        this.gridsterComponent = gridsterComponent;\n\n        this.draggableOptions = gridsterComponent.draggableOptions;\n\n        this.gridsterOptions = gridsterComponent.gridsterOptions;\n    }\n\n    start() {\n        this.updateMaxItemSize();\n\n        // Used to highlight a position an element will land on upon drop\n        if (this.$positionHighlight) {\n            this.removePositionHighlight();\n        }\n\n        this.initGridList();\n\n        this.isInit = true;\n\n        setTimeout(() => {\n            this.copyItems();\n            this.fixItemsPositions();\n\n            this.gridsterComponent.reflowGridster(true);\n            this.gridsterComponent.setReady();\n        });\n    }\n\n    initGridList() {\n        // Create instance of GridList (decoupled lib for handling the grid\n        // positioning and sorting post-drag and dropping)\n        this.gridList = new GridList(this.items, this.options);\n    }\n\n    render() {\n        this.updateMaxItemSize();\n        this.gridList.generateGrid();\n        this.applySizeToItems();\n        this.applyPositionToItems();\n        this.refreshLines();\n    }\n\n    reflow() {\n        this.calculateCellSize();\n        this.render();\n    }\n\n    fixItemsPositions() {\n        if (this.options.responsiveSizes) {\n            this.gridList.fixItemsPositions(this.options);\n        } else {\n            this.gridList.fixItemsPositions(this.gridsterOptions.basicOptions);\n            this.gridsterOptions.responsiveOptions.forEach((options: IGridsterOptions) => {\n                this.gridList.fixItemsPositions(options);\n            });\n        }\n\n        this.updateCachedItems();\n    }\n\n    removeItem(item: GridListItem) {\n        const idx = this.items.indexOf(item);\n\n        if (idx >= 0) {\n            this.items.splice(this.items.indexOf(item), 1);\n        }\n\n        this.gridList.deleteItemPositionFromGrid(item);\n        this.removeItemFromCache(item);\n    }\n\n    onResizeStart(item: GridListItem) {\n        this.currentElement = item.$element;\n\n        this.copyItems();\n\n        this._maxGridCols = this.gridList.grid.length;\n\n        this.highlightPositionForItem(item);\n\n        this.gridsterComponent.isResizing = true;\n\n        this.refreshLines();\n    }\n\n    onResizeDrag(item: GridListItem) {\n        const newSize = this.snapItemSizeToGrid(item);\n        const sizeChanged = this.dragSizeChanged(newSize);\n        const newPosition = this.snapItemPositionToGrid(item);\n        const positionChanged = this.dragPositionChanged(newPosition);\n\n        if (sizeChanged || positionChanged) {\n            // Regenerate the grid with the positions from when the drag started\n            this.restoreCachedItems();\n            this.gridList.generateGrid();\n\n            this.previousDragPosition = newPosition;\n            this.previousDragSize = newSize;\n\n            this.gridList.moveAndResize(item, newPosition, {w: newSize[0], h: newSize[1]});\n\n            // Visually update item positions and highlight shape\n            this.applyPositionToItems(true);\n            this.applySizeToItems();\n            this.highlightPositionForItem(item);\n            this.refreshLines();\n        }\n    }\n\n    onResizeStop(item: GridListItem) {\n        this.currentElement = undefined;\n        this.updateCachedItems();\n        this.previousDragSize = null;\n\n        this.removePositionHighlight();\n\n        this.gridsterComponent.isResizing = false;\n\n        this.gridList.pullItemsToLeft(item);\n        this.debounceRenderSubject.next();\n\n        this.fixItemsPositions();\n    }\n\n    onStart(item: GridListItem) {\n        this.currentElement = item.$element;\n        // itemCtrl.isDragging = true;\n        // Create a deep copy of the items; we use them to revert the item\n        // positions after each drag change, making an entire drag operation less\n        // distructable\n        this.copyItems();\n\n        // Since dragging actually alters the grid, we need to establish the number\n        // of cols (+1 extra) before the drag starts\n\n        this._maxGridCols = this.gridList.grid.length;\n\n        this.gridsterComponent.isDragging = true;\n        this.gridsterComponent.updateGridsterElementData();\n\n        this.refreshLines();\n    }\n\n    onDrag(item: GridListItem) {\n        const newPosition = this.snapItemPositionToGrid(item);\n\n        if (this.dragPositionChanged(newPosition)) {\n\n            // Regenerate the grid with the positions from when the drag started\n            this.restoreCachedItems();\n            this.gridList.generateGrid();\n\n            this.previousDragPosition = newPosition;\n            if (this.options.direction === 'none' &&\n                !this.gridList.checkItemAboveEmptyArea(item, {x: newPosition[0], y: newPosition[1]})) {\n                return;\n            }\n\n            // Since the items list is a deep copy, we need to fetch the item\n            // corresponding to this drag action again\n            this.gridList.moveItemToPosition(item, newPosition);\n\n            // Visually update item positions and highlight shape\n            this.applyPositionToItems(true);\n            this.highlightPositionForItem(item);\n        }\n    }\n\n    cancel() {\n        this.restoreCachedItems();\n        this.previousDragPosition = null;\n        this.updateMaxItemSize();\n        this.applyPositionToItems();\n        this.removePositionHighlight();\n        this.currentElement = undefined;\n        this.gridsterComponent.isDragging = false;\n    }\n\n    onDragOut (item: GridListItem) {\n\n        this.cancel();\n\n        const idx = this.items.indexOf(item);\n        if (idx >= 0) {\n            this.items.splice(idx, 1);\n        }\n\n        this.gridList.pullItemsToLeft();\n        this.render();\n    }\n\n    onStop(item: GridListItem) {\n        this.currentElement = undefined;\n        this.updateCachedItems();\n        this.previousDragPosition = null;\n\n        this.removePositionHighlight();\n\n        this.gridList.pullItemsToLeft(item);\n\n        this.gridsterComponent.isDragging = false;\n\n        this.refreshLines();\n    }\n\n    calculateCellSize() {\n        if (this.options.direction === 'horizontal') {\n            this.cellHeight = this.calculateCellHeight();\n            this.cellWidth = this.options.cellWidth || this.cellHeight * this.options.widthHeightRatio;\n        } else {\n            this.cellWidth = this.calculateCellWidth();\n            this.cellHeight = this.options.cellHeight || this.cellWidth / this.options.widthHeightRatio;\n        }\n        if (this.options.heightToFontSizeRatio) {\n            this._fontSize = this.cellHeight * this.options.heightToFontSizeRatio;\n        }\n    }\n\n    applyPositionToItems(increaseGridsterSize?: boolean) {\n        if (!this.options.shrink) {\n            increaseGridsterSize = true;\n        }\n        // TODO: Implement group separators\n        for (let i = 0; i < this.items.length; i++) {\n            // Don't interfere with the positions of the dragged items\n            if (this.isCurrentElement(this.items[i].$element)) {\n                continue;\n            }\n            this.items[i].applyPosition(this);\n        }\n\n        const child = <HTMLElement>this.gridsterComponent.$element.firstChild;\n        // Update the width of the entire grid container with enough room on the\n        // right to allow dragging items to the end of the grid.\n        if (this.options.direction === 'horizontal') {\n            const increaseWidthWith = (increaseGridsterSize) ? this.maxItemWidth : 0;\n            child.style.height = '';\n            child.style.width = ((this.gridList.grid.length + increaseWidthWith) * this.cellWidth) + 'px';\n\n        } else if (this.gridList.grid.length) {\n            // todo: fix me\n            const rowHeights = this.getRowHeights();\n            const rowTops = this.getRowTops(rowHeights);\n            const height = rowTops[rowTops.length - 1] + rowHeights[rowHeights.length - 1];\n            const previousHeight = child.style.height;\n            child.style.height = height + 'px';\n            child.style.width = '';\n\n            if (previousHeight !== child.style.height) {\n                this.refreshLines();\n            }\n        }\n    }\n\n    getRowHeights(): number[] {\n        const result = [];\n        for (let row = 0; row < this.gridList.grid.length; row++) {\n            result.push(0);\n            for (let column = 0; column < this.gridList.grid[row].length; column++) {\n                const item = this.gridList.grid[row][column];\n                if (item) {\n                    const height = item.contentHeight / item.h;\n                    if (item.variableHeight && height > result[row]) {\n                        result[row] = height;\n                    }\n                }\n            }\n            if (result[row] === 0) {\n                result[row] = this.cellHeight;\n            }\n        }\n        return result;\n    }\n\n    getRowTops(rowHeights: number[]): number[] {\n        const result = [];\n        let lastHeight = 0;\n        for (const rowHeight of rowHeights) {\n            result.push(lastHeight);\n            lastHeight += rowHeight;\n        }\n        return result;\n    }\n\n    refreshLines() {\n        const canvas = <HTMLCanvasElement>this.gridsterComponent.$backgroundGrid.nativeElement;\n        canvas.width = canvas.offsetWidth;\n        canvas.height = canvas.offsetHeight;\n        const canvasContext = canvas.getContext('2d');\n\n        canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n\n        if (this.options.lines && this.options.lines.visible &&\n            (this.gridsterComponent.isDragging || this.gridsterComponent.isResizing || this.options.lines.always)) {\n            const linesColor = this.options.lines.color || '#d8d8d8';\n            const linesBgColor = this.options.lines.backgroundColor || 'transparent';\n            const linesWidth = this.options.lines.width || 1;\n\n            canvasContext.fillStyle = linesBgColor;\n            canvasContext.fillRect(0, 0, canvas.width, canvas.height);\n\n            canvasContext.strokeStyle = linesColor;\n            canvasContext.lineWidth = linesWidth;\n\n            canvasContext.beginPath();\n            // draw row lines\n            const rowHeights = this.getRowHeights();\n            const rowTops = this.getRowTops(rowHeights);\n            for (let i = 0; i < rowTops.length; i++) {\n                canvasContext.moveTo(0, rowTops[i]);\n                canvasContext.lineTo(canvas.width, rowTops[i]);\n            }\n            // draw column lines\n            for (let i = 0; i < this.options.lanes; i++) {\n                canvasContext.moveTo(i * this.cellWidth, 0);\n                canvasContext.lineTo(i * this.cellWidth, canvas.height);\n            }\n            canvasContext.stroke();\n            canvasContext.closePath();\n        }\n    }\n\n    private removeItemFromCache(item: GridListItem) {\n        this._items = this._items\n            .filter(cachedItem => cachedItem.$element !== item.$element);\n\n        Object.keys(this._itemsMap)\n            .forEach((breakpoint: string) => {\n                this._itemsMap[breakpoint] = this._itemsMap[breakpoint]\n                    .filter(cachedItem => cachedItem.$element !== item.$element);\n            });\n    }\n\n    private copyItems(): void {\n        this._items = this.items\n            .filter(item => this.isValidGridItem(item))\n            .map((item: GridListItem) => {\n                return item.copyForBreakpoint(null);\n            });\n\n        this.gridsterOptions.responsiveOptions.forEach((options: IGridsterOptions) => {\n            this._itemsMap[options.breakpoint] = this.items\n                .filter(item => this.isValidGridItem(item))\n                .map((item: GridListItem) => {\n                    return item.copyForBreakpoint(options.breakpoint);\n                });\n        });\n    }\n\n    /**\n     * Update maxItemWidth and maxItemHeight vales according to current state of items\n     */\n    private updateMaxItemSize() {\n        this.maxItemWidth = Math.max.apply(\n            null, this.items.map((item) => {\n                return item.w;\n            }));\n        this.maxItemHeight = Math.max.apply(\n            null, this.items.map((item) => {\n                return item.h;\n            }));\n    }\n\n    /**\n     * Update items properties of previously cached items\n     */\n    private restoreCachedItems() {\n        const items = this.options.breakpoint ? this._itemsMap[this.options.breakpoint] : this._items;\n\n        this.items\n            .filter(item => this.isValidGridItem(item))\n            .forEach((item: GridListItem) => {\n                const cachedItem: GridListItem = items.filter(cachedItm => {\n                    return cachedItm.$element === item.$element;\n                })[0];\n\n                item.x = cachedItem.x;\n                item.y = cachedItem.y;\n\n                item.w = cachedItem.w;\n                item.h = cachedItem.h;\n                item.autoSize = cachedItem.autoSize;\n            });\n    }\n\n    /**\n     * If item should react on grid\n     * @param GridListItem item\n     * @returns boolean\n     */\n    private isValidGridItem(item: GridListItem): boolean {\n        if (this.options.direction === 'none') {\n            return !!item.itemComponent;\n        }\n        return true;\n    }\n\n    private calculateCellWidth() {\n        const gridsterWidth = parseFloat(window.getComputedStyle(this.gridsterComponent.$element).width);\n\n        return gridsterWidth / this.options.lanes;\n    }\n\n    private calculateCellHeight() {\n        const gridsterHeight = parseFloat(window.getComputedStyle(this.gridsterComponent.$element).height);\n\n        return gridsterHeight / this.options.lanes;\n    }\n\n    private applySizeToItems() {\n        for (let i = 0; i < this.items.length; i++) {\n            this.items[i].applySize();\n\n            if (this.options.heightToFontSizeRatio) {\n                this.items[i].$element.style['font-size'] = this._fontSize;\n            }\n        }\n    }\n\n    private isCurrentElement(element: HTMLElement) {\n        if (!this.currentElement) {\n            return false;\n        }\n        return element === this.currentElement;\n    }\n\n    private snapItemSizeToGrid(item: GridListItem): [number, number] {\n        const itemSize = {\n            width: parseInt(item.$element.style.width, 10) - 1,\n            height: parseInt(item.$element.style.height, 10) - 1\n        };\n\n        let colSize = Math.round(itemSize.width / this.cellWidth);\n        let rowSize = Math.round(itemSize.height / this.cellHeight);\n\n        // Keep item minimum 1\n        colSize = Math.max(colSize, 1);\n        rowSize = Math.max(rowSize, 1);\n\n        // check if element is pinned\n        if (this.gridList.isOverFixedArea(item.x, item.y, colSize, rowSize, item)) {\n            return [item.w, item.h];\n        }\n\n        return [colSize, rowSize];\n    }\n\n    private generateItemPosition(item: GridListItem): { x: number, y: number } {\n        let position;\n\n        if (item.itemPrototype) {\n            const coords = item.itemPrototype.getPositionToGridster(this);\n            position = {\n                x: Math.round(coords.x / this.cellWidth),\n                y: Math.round(coords.y / this.cellHeight)\n            };\n        } else {\n            position = {\n                x: Math.round(item.positionX / this.cellWidth),\n                y: Math.round(item.positionY / this.cellHeight)\n            };\n        }\n\n        return position;\n    }\n\n    private snapItemPositionToGrid(item: GridListItem): [number, number] {\n        const position = this.generateItemPosition(item);\n        let col = position.x;\n        let row = position.y;\n\n        // Keep item position within the grid and don't let the item create more\n        // than one extra column\n        col = Math.max(col, 0);\n        row = Math.max(row, 0);\n\n        if (this.options.direction === 'horizontal') {\n            col = Math.min(col, this._maxGridCols);\n        } else {\n            col = Math.min(col, Math.max(0, this.options.lanes - item.w));\n        }\n\n        // check if element is pinned\n        if (this.gridList.isOverFixedArea(col, row, item.w, item.h)) {\n            return [item.x, item.y];\n        }\n\n        return [col, row];\n    }\n\n    private dragSizeChanged(newSize: [number, number]): boolean {\n        if (!this.previousDragSize) {\n            return true;\n        }\n        return (newSize[0] !== this.previousDragSize[0] ||\n            newSize[1] !== this.previousDragSize[1]);\n    }\n\n    private dragPositionChanged(newPosition: [number, number]): boolean {\n        if (!this.previousDragPosition) {\n            return true;\n        }\n        return (newPosition[0] !== this.previousDragPosition[0] ||\n            newPosition[1] !== this.previousDragPosition[1]);\n    }\n\n    private highlightPositionForItem(item: GridListItem) {\n        const size = item.calculateSize(this);\n        const position = item.calculatePosition(this);\n\n        this.$positionHighlight.style.width = size.width + 'px';\n        this.$positionHighlight.style.height = size.height + 'px';\n        this.$positionHighlight.style.left = position.left + 'px';\n        this.$positionHighlight.style.top = position.top + 'px';\n        this.$positionHighlight.style.display = '';\n\n        if (this.options.heightToFontSizeRatio) {\n            (<any>this.$positionHighlight.style)['font-size'] = this._fontSize;\n        }\n    }\n\n    public updateCachedItems() {\n        // Notify the user with the items that changed since the previous snapshot\n        this.triggerOnChange(null);\n        this.gridsterOptions.responsiveOptions.forEach((options: IGridsterOptions) => {\n            this.triggerOnChange(options.breakpoint);\n        });\n\n        this.copyItems();\n    }\n\n    private triggerOnChange(breakpoint?: string) {\n        const items = breakpoint ? this._itemsMap[breakpoint] : this._items;\n        const changeItems = this.gridList.getChangedItems(items || [], breakpoint);\n\n        changeItems\n            .filter((itemChange: any) => {\n                return itemChange.item.itemComponent;\n            })\n            .forEach((itemChange: any) => {\n\n                if (itemChange.changes.indexOf('x') >= 0) {\n                    itemChange.item.triggerChangeX(breakpoint);\n                }\n                if (itemChange.changes.indexOf('y') >= 0) {\n                    itemChange.item.triggerChangeY(breakpoint);\n                }\n                if (itemChange.changes.indexOf('w') >= 0) {\n                    itemChange.item.triggerChangeW(breakpoint);\n                }\n                if (itemChange.changes.indexOf('h') >= 0) {\n                    itemChange.item.triggerChangeH(breakpoint);\n                }\n                // should be called only once (not for each breakpoint)\n                itemChange.item.itemComponent.change.emit({\n                    item: itemChange.item,\n                    oldValues: itemChange.oldValues || {},\n                    isNew: itemChange.isNew,\n                    changes: itemChange.changes,\n                    breakpoint: breakpoint\n                });\n            });\n    }\n\n    private removePositionHighlight() {\n        this.$positionHighlight.style.display = 'none';\n    }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { takeUntil, switchMap, map, scan, filter, share, tap } from 'rxjs/operators';\n\nimport { GridsterService } from '../gridster.service';\nimport { GridsterItemPrototypeDirective } from './gridster-item-prototype.directive';\nimport { utils } from '../utils/utils';\nimport {DraggableEvent} from '../utils/DraggableEvent';\nimport { merge } from 'rxjs';\n\n@Injectable()\nexport class GridsterPrototypeService {\n\n    private isDragging = false;\n\n    private dragSubject = new Subject<any>();\n\n    private dragStartSubject = new Subject<any>();\n\n    private dragStopSubject = new Subject<any>();\n\n    constructor() {}\n\n    observeDropOver (gridster: GridsterService) {\n        return this.dragStopSubject.pipe(\n            filter((data: any) => {\n                const gridsterEl = gridster.gridsterComponent.$element;\n                const isOverNestedGridster = [].slice.call(gridsterEl.querySelectorAll('gridster'))\n                    .reduce((isOverGridster: boolean, nestedGridsterEl: HTMLElement) => {\n                        return isOverGridster ||\n                            this.isOverGridster(data.item, nestedGridsterEl, data.event, gridster.options);\n                    }, false);\n\n                if (isOverNestedGridster) {\n                    return false;\n                }\n\n                return this.isOverGridster(data.item, gridsterEl, data.event, gridster.options);\n            }),\n            tap((data: any) => {\n                // TODO: what we should provide as a param?\n                // prototype.drop.emit({item: prototype.item});\n                data.item.onDrop(gridster);\n            })\n        );\n    }\n\n    observeDropOut (gridster: GridsterService) {\n        return this.dragStopSubject.pipe(\n            filter((data: any) => {\n                const gridsterEl = gridster.gridsterComponent.$element;\n\n                return !this.isOverGridster(data.item, gridsterEl, data.event, gridster.options);\n            }),\n            tap((data: any) => {\n                // TODO: what we should provide as a param?\n                data.item.onCancel();\n            })\n        );\n    }\n\n    observeDragOver(gridster: GridsterService): {\n        dragOver: Observable<GridsterItemPrototypeDirective>,\n        dragEnter: Observable<GridsterItemPrototypeDirective>,\n        dragOut: Observable<GridsterItemPrototypeDirective>\n    } {\n        const over = this.dragSubject.pipe(\n            map((data: any) => {\n                const gridsterEl = gridster.gridsterComponent.$element;\n\n                return {\n                  item: data.item,\n                  event: data.event,\n                  isOver: this.isOverGridster(data.item, gridsterEl, data.event, gridster.options),\n                  isDrop: false\n                };\n            })\n        );\n\n        const drop = this.dragStopSubject.pipe(\n            map((data: any) => {\n                const gridsterEl = gridster.gridsterComponent.$element;\n\n                return {\n                    item: data.item,\n                    event: data.event,\n                    isOver: this.isOverGridster(data.item, gridsterEl, data.event, gridster.options),\n                    isDrop: true\n                };\n            })\n        );\n\n        const dragExt = merge(\n                // dragStartSubject is connected in case when item prototype is placed above gridster\n                // and drag enter is not fired\n                this.dragStartSubject.pipe(map(() => ({ item: null, isOver: false, isDrop: false }))),\n                over,\n                drop\n            ).pipe(\n                scan((prev: any, next: any) => {\n                    return {\n                        item: next.item,\n                        event: next.event,\n                        isOver: next.isOver,\n                        isEnter: prev.isOver === false && next.isOver === true,\n                        isOut: prev.isOver === true && next.isOver === false && !prev.isDrop,\n                        isDrop: next.isDrop\n                    };\n                }),\n                filter((data: any) => {\n                    return !data.isDrop;\n                }),\n                share()\n            );\n\n        const dragEnter = this.createDragEnterObservable(dragExt, gridster);\n        const dragOut = this.createDragOutObservable(dragExt, gridster);\n        const dragOver = dragEnter\n            .pipe(\n                switchMap(() => this.dragSubject.pipe(takeUntil(dragOut))),\n                map((data: any) => data.item)\n            );\n\n        return { dragEnter, dragOut, dragOver };\n    }\n\n    dragItemStart(item: GridsterItemPrototypeDirective, event: DraggableEvent) {\n        this.isDragging = true;\n        this.dragStartSubject.next({ item, event });\n    }\n\n    dragItemStop(item: GridsterItemPrototypeDirective, event: DraggableEvent) {\n        this.isDragging = false;\n        this.dragStopSubject.next({ item, event });\n    }\n\n    updatePrototypePosition(item: GridsterItemPrototypeDirective, event: DraggableEvent) {\n        this.dragSubject.next({ item, event });\n    }\n\n    /**\n     * Creates observable that is fired on dragging over gridster container.\n     */\n    public createDragOverObservable (\n        dragIsOver: Observable<{item: GridsterItemPrototypeDirective, isOver: boolean}>,\n        gridster: GridsterService\n    ) {\n        return dragIsOver.pipe(\n            filter((data: any) => data.isOver && !data.isEnter && !data.isOut),\n            map((data: any): GridsterItemPrototypeDirective => data.item),\n            tap((item: GridsterItemPrototypeDirective) => item.onOver(gridster))\n        );\n    }\n    /**\n     * Creates observable that is fired on drag enter gridster container.\n     */\n    private createDragEnterObservable (\n        dragIsOver: Observable<{item: GridsterItemPrototypeDirective, isOver: boolean}>,\n        gridster: GridsterService\n    ) {\n        return dragIsOver.pipe(\n            filter((data: any) => data.isEnter),\n            map((data: any): GridsterItemPrototypeDirective => data.item),\n            tap((item: GridsterItemPrototypeDirective) => item.onEnter(gridster))\n        );\n    }\n    /**\n     * Creates observable that is fired on drag out gridster container.\n     */\n    private createDragOutObservable (\n        dragIsOver: Observable<{item: GridsterItemPrototypeDirective,\n        isOver: boolean}>,\n        gridster: GridsterService\n    ) {\n        return dragIsOver.pipe(\n            filter((data: any) => data.isOut),\n            map((data: any): GridsterItemPrototypeDirective => data.item),\n            tap((item: GridsterItemPrototypeDirective) => item.onOut(gridster))\n        );\n    }\n\n    /**\n     * Checks whether \"element\" position fits inside \"containerEl\" position.\n     * It checks if \"element\" is totally covered by \"containerEl\" area.\n     */\n    private isOverGridster(item: GridsterItemPrototypeDirective, gridsterEl: HTMLElement, event: any, options: any): boolean {\n        const el = item.$element;\n        const parentItem = <HTMLElement>gridsterEl.parentElement &&\n            <HTMLElement>gridsterEl.parentElement.closest('gridster-item');\n\n        if (parentItem) {\n            return this.isOverGridster(item, parentItem, event, options);\n        }\n\n        switch (options.tolerance) {\n            case 'fit':\n                return utils.isElementFitContainer(el, gridsterEl);\n            case 'intersect':\n                return utils.isElementIntersectContainer(el, gridsterEl);\n            case 'touch':\n                return utils.isElementTouchContainer(el, gridsterEl);\n            default:\n                return utils.isCursorAboveElement(event, gridsterEl);\n        }\n    }\n}\n","import { Observable, merge, fromEvent, of } from 'rxjs';\nimport { debounceTime, map, distinctUntilChanged } from 'rxjs/operators';\n\nimport { IGridsterOptions } from './IGridsterOptions';\n\nexport class GridsterOptions {\n    direction: string;\n    lanes: number;\n    widthHeightRatio: number;\n    heightToFontSizeRatio: number;\n    responsiveView: boolean;\n    responsiveSizes: boolean;\n    responsiveToParent: boolean;\n    dragAndDrop: boolean;\n    resizable: boolean;\n    shrink: boolean;\n    minWidth: number;\n    useCSSTransforms: boolean;\n\n    defaults: IGridsterOptions = {\n        lanes: 5,\n        direction: 'horizontal',\n        widthHeightRatio: 1,\n        shrink: false,\n        responsiveView: true,\n        responsiveSizes: false,\n        responsiveToParent: false,\n        dragAndDrop: true,\n        resizable: false,\n        useCSSTransforms: false,\n        floating: true,\n        tolerance: 'pointer'\n    };\n\n    change: Observable<IGridsterOptions>;\n\n    responsiveOptions: Array<IGridsterOptions> = [];\n    basicOptions: IGridsterOptions;\n\n    breakpointsMap: {[index: string]: number} = {\n        sm: 576, // Small devices\n        md: 768, // Medium devices\n        lg: 992, // Large devices\n        xl: 1200 // Extra large\n    };\n\n    constructor(config: IGridsterOptions, gridsterElement: HTMLElement) {\n        const responsiveContainer = config.responsiveToParent ? gridsterElement : window;\n\n        this.basicOptions = config;\n        this.responsiveOptions = this.extendResponsiveOptions(config.responsiveOptions || []);\n\n        this.change = merge(\n                of(this.getOptionsByWidth(this.getElementWidth(responsiveContainer))),\n                fromEvent(window, 'resize').pipe(\n                    debounceTime(config.responsiveDebounce || 0),\n                    map((event: Event) => this.getOptionsByWidth(this.getElementWidth(responsiveContainer)))\n                )\n            ).pipe(distinctUntilChanged(null, (options: any) => options.minWidth));\n    }\n\n    getOptionsByWidth(width: number): IGridsterOptions {\n        let i = 0;\n        let options: IGridsterOptions = Object.assign({}, this.defaults, this.basicOptions);\n\n        while (this.responsiveOptions[i]) {\n            if (this.responsiveOptions[i].minWidth <= width) {\n                options = this.responsiveOptions[i];\n            }\n            i++;\n        }\n\n        return options;\n    }\n\n    private extendResponsiveOptions(responsiveOptions: Array<IGridsterOptions>): Array<IGridsterOptions> {\n        return responsiveOptions\n            // responsive options are valid only with \"breakpoint\" property\n            .filter(options => options.breakpoint)\n            // set default minWidth if not given\n            .map((options) => {\n                return Object.assign({\n                    minWidth: this.breakpointsMap[options.breakpoint] || 0\n                }, options);\n            })\n            .sort((curr, next) => curr.minWidth - next.minWidth)\n            .map((options) => <IGridsterOptions>Object.assign({}, this.defaults, this.basicOptions, options));\n    }\n\n    private getElementWidth($element: any) {\n        if ($element === window) {\n            return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n        }\n\n        return $element.clientWidth;\n    }\n}\n","import {\n    Component,\n    OnInit,\n    AfterContentInit,\n    OnDestroy,\n    ElementRef,\n    ViewChild,\n    NgZone,\n    Input,\n    Output,\n    EventEmitter,\n    ChangeDetectionStrategy,\n    HostBinding,\n    ViewEncapsulation\n} from '@angular/core';\nimport {\n    Observable,\n    Subscription,\n    fromEvent,\n    ConnectableObservable\n} from 'rxjs';\nimport { debounceTime, filter, publish } from 'rxjs/operators';\n\nimport { utils } from './utils/utils';\nimport { GridsterService } from './gridster.service';\nimport { IGridsterOptions } from './IGridsterOptions';\nimport { IGridsterDraggableOptions } from './IGridsterDraggableOptions';\nimport { GridsterPrototypeService } from './gridster-prototype/gridster-prototype.service';\nimport { GridsterItemPrototypeDirective } from './gridster-prototype/gridster-item-prototype.directive';\nimport { GridListItem } from './gridList/GridListItem';\nimport { GridsterOptions } from './GridsterOptions';\n\n@Component({\n    selector: 'ngx-gridster',\n    template: `<div class=\"gridster-container\">\n      <canvas class=\"gridster-background-grid\" #backgroundGrid></canvas>\n      <ng-content></ng-content>\n      <div class=\"position-highlight\" style=\"display:none;\" #positionHighlight>\n        <div class=\"inner\"></div>\n      </div>\n    </div>`,\n    styles: [\n        `\n            ngx-gridster {\n                position: relative;\n                display: block;\n                left: 0;\n                width: 100%;\n            }\n\n            ngx-gridster.gridster--dragging {\n                -moz-user-select: none;\n                -khtml-user-select: none;\n                -webkit-user-select: none;\n                -ms-user-select: none;\n                user-select: none;\n            }\n\n            ngx-gridster .gridster-container {\n                position: relative;\n                width: 100%;\n                list-style: none;\n                -webkit-transition: width 0.2s, height 0.2s;\n                transition: width 0.2s, height 0.2s;\n            }\n\n    ngx-gridster .position-highlight {\n        display: block;\n        position: absolute;\n        z-index: 1;\n    }\n\n    ngx-gridster .gridster-background-grid {\n        z-index: 0;\n        position: relative;\n        width: 100%;\n        height: 100%\n    }\n    `],\n    providers: [GridsterService],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None\n})\nexport class GridsterComponent implements OnInit, AfterContentInit, OnDestroy {\n    @Input() public options: IGridsterOptions;\n    @Output() public optionsChange = new EventEmitter<any>();\n    @Output() public ready = new EventEmitter<any>();\n    @Output() public reflow = new EventEmitter<any>();\n    @Output() public prototypeDrop = new EventEmitter<{item: GridListItem}>();\n    @Output() public prototypeEnter = new EventEmitter<{item: GridListItem}>();\n    @Output() public prototypeOut = new EventEmitter<{item: GridListItem}>();\n    @Input() public draggableOptions: IGridsterDraggableOptions;\n    @Input() public parent: GridsterComponent;\n\n    @ViewChild('positionHighlight', { static: true }) $positionHighlight;\n    @ViewChild('backgroundGrid') public $backgroundGrid: any;\n    @HostBinding('class.gridster--dragging') isDragging = false;\n    @HostBinding('class.gridster--resizing') isResizing = false;\n\n    @HostBinding('class.gridster--ready') public isReady = false;\n    public gridster: GridsterService;\n    public $element: HTMLElement;\n\n    public gridsterOptions: GridsterOptions;\n    public isPrototypeEntered = false;\n    private isDisabled = false;\n    private subscription = new Subscription();\n\n    constructor(\n        private zone: NgZone,\n        elementRef: ElementRef,\n        gridster: GridsterService,\n        private gridsterPrototype: GridsterPrototypeService\n    ) {\n        this.gridster = gridster;\n        this.$element = elementRef.nativeElement;\n    }\n\n    ngOnInit() {\n        this.gridsterOptions = new GridsterOptions(this.options, this.$element);\n\n        if (this.options.useCSSTransforms) {\n            this.$element.classList.add('css-transform');\n        }\n\n        this.subscription.add(\n            this.gridsterOptions.change.subscribe(options => {\n                this.gridster.options = options;\n                if (this.gridster.gridList) {\n                    this.gridster.gridList.options = options;\n                }\n                setTimeout(() => this.optionsChange.emit(options));\n            })\n        );\n\n        this.gridster.init(this);\n\n        this.subscription.add(\n            fromEvent(window, 'resize')\n                .pipe(\n                    debounceTime(this.gridster.options.responsiveDebounce || 0),\n                    filter(() => this.gridster.options.responsiveView)\n                )\n                .subscribe(() => this.reload())\n        );\n\n        this.zone.runOutsideAngular(() => {\n            this.subscription.add(\n                fromEvent(document, 'scroll', { passive: true }).subscribe(() =>\n                    this.updateGridsterElementData()\n                )\n            );\n            const scrollableContainer = utils.getScrollableContainer(this.$element);\n            if (scrollableContainer) {\n                this.subscription.add(\n                    fromEvent(scrollableContainer, 'scroll', { passive: true })\n                    .subscribe(() =>\n                        this.updateGridsterElementData()\n                    )\n                );\n            }\n        });\n        const scrollableContainer = utils.getScrollableContainer(this.$element);\n        if (scrollableContainer) {\n            this.subscription.add(\n                fromEvent(scrollableContainer, 'scroll', { passive: true })\n                .subscribe(() =>\n                    this.updateGridsterElementData()\n                )\n            );\n        }\n    }\n\n    ngAfterContentInit() {\n        this.gridster.start();\n\n        this.updateGridsterElementData();\n\n        this.connectGridsterPrototype();\n\n        this.gridster.$positionHighlight = this.$positionHighlight.nativeElement;\n    }\n\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n\n    /**\n     * Change gridster config option and rebuild\n     * @param string name\n     * @param any value\n     * @return GridsterComponent\n     */\n    setOption(name: keyof IGridsterOptions, value: any) {\n        if (name === 'dragAndDrop') {\n            if (value) {\n                this.enableDraggable();\n            } else {\n                this.disableDraggable();\n            }\n        }\n        if (name === 'resizable') {\n            if (value) {\n                this.enableResizable();\n            } else {\n                this.disableResizable();\n            }\n        }\n        if (name === 'lanes') {\n            this.gridster.options.lanes = value;\n\n            this.gridster.gridList.fixItemsPositions(this.gridster.options);\n            this.reflowGridster();\n        }\n        if (name === 'direction') {\n            this.gridster.options.direction = value;\n            this.gridster.gridList.pullItemsToLeft();\n        }\n        if (name === 'widthHeightRatio') {\n            this.gridster.options.widthHeightRatio = parseFloat(value || 1);\n        }\n        if (name === 'responsiveView') {\n            this.gridster.options.responsiveView = !!value;\n        }\n        this.gridster.gridList.setOption(name, value);\n\n        return this;\n    }\n\n    reload() {\n        setTimeout(() => {\n            this.gridster.fixItemsPositions();\n            this.reflowGridster();\n        });\n\n        return this;\n    }\n\n    reflowGridster(isInit = false) {\n        this.gridster.reflow();\n        this.reflow.emit({\n            isInit: isInit,\n            gridsterComponent: this\n        });\n    }\n\n    updateGridsterElementData() {\n        this.gridster.gridsterScrollData = this.getScrollPositionFromParents(\n            this.$element\n        );\n        this.gridster.gridsterRect = this.$element.getBoundingClientRect();\n    }\n\n    setReady() {\n        setTimeout(() => (this.isReady = true));\n        this.ready.emit();\n    }\n\n    adjustItemsHeightToContent(\n        scrollableItemElementSelector: string = '.gridster-item-inner'\n    ) {\n        this.gridster.items\n            // convert each item to object with information about content height and scroll height\n            .map((item: GridListItem) => {\n                const scrollEl = item.$element.querySelector(\n                    scrollableItemElementSelector\n                );\n                const contentEl = scrollEl.lastElementChild;\n                const scrollElDistance = utils.getRelativeCoordinates(\n                    scrollEl,\n                    item.$element\n                );\n                const scrollElRect = scrollEl.getBoundingClientRect();\n                const contentRect = contentEl.getBoundingClientRect();\n\n                return {\n                    item,\n                    contentHeight: contentRect.bottom - scrollElRect.top,\n                    scrollElDistance\n                };\n            })\n            // calculate required height in lanes amount and update item \"h\"\n            .forEach(data => {\n                data.item.h = Math.ceil(<any>(\n                    (data.contentHeight /\n                        (this.gridster.cellHeight - data.scrollElDistance.top))\n                ));\n            });\n\n        this.gridster.fixItemsPositions();\n        this.gridster.reflow();\n    }\n\n    disable(item: any) {\n        const itemIdx = this.gridster.items.indexOf(item.itemComponent);\n\n        this.isDisabled = true;\n        if (itemIdx >= 0) {\n            delete this.gridster.items[\n                this.gridster.items.indexOf(item.itemComponent)\n            ];\n        }\n        this.gridster.onDragOut(item);\n    }\n\n    enable() {\n        this.isDisabled = false;\n    }\n\n    private getScrollPositionFromParents(\n        element: Element,\n        data = { scrollTop: 0, scrollLeft: 0 }\n    ): { scrollTop: number; scrollLeft: number } {\n        if (element.parentElement && element.parentElement !== document.body) {\n            data.scrollTop += element.parentElement.scrollTop;\n            data.scrollLeft += element.parentElement.scrollLeft;\n\n            return this.getScrollPositionFromParents(\n                element.parentElement,\n                data\n            );\n        }\n\n        return {\n            scrollTop: data.scrollTop,\n            scrollLeft: data.scrollLeft\n        };\n    }\n\n    /**\n     * Connect gridster prototype item to gridster dragging hooks (onStart, onDrag, onStop).\n     */\n    private connectGridsterPrototype() {\n        this.gridsterPrototype.observeDropOut(this.gridster).subscribe();\n\n        const dropOverObservable = <ConnectableObservable<any>>(\n            this.gridsterPrototype\n                .observeDropOver(this.gridster)\n                .pipe(publish())\n        );\n\n        const dragObservable = this.gridsterPrototype.observeDragOver(\n            this.gridster\n        );\n\n        dragObservable.dragOver\n            .pipe(filter(() => !this.isDisabled))\n            .subscribe((prototype: GridsterItemPrototypeDirective) => {\n                if (!this.isPrototypeEntered) {\n                    return;\n                }\n                this.gridster.onDrag(prototype.item);\n            });\n\n        dragObservable.dragEnter\n            .pipe(filter(() => !this.isDisabled))\n            .subscribe((prototype: GridsterItemPrototypeDirective) => {\n                this.isPrototypeEntered = true;\n\n                if (this.gridster.items.indexOf(prototype.item) < 0) {\n                    this.gridster.items.push(prototype.item);\n                }\n                this.gridster.onStart(prototype.item);\n                prototype.setDragContextGridster(this.gridster);\n\n                if (this.parent) {\n                    this.parent.disable(prototype.item);\n                }\n                this.prototypeEnter.emit({ item: prototype.item });\n            });\n\n        dragObservable.dragOut\n            .pipe(filter(() => !this.isDisabled))\n            .subscribe((prototype: GridsterItemPrototypeDirective) => {\n                if (!this.isPrototypeEntered) {\n                    return;\n                }\n                this.gridster.onDragOut(prototype.item);\n                this.isPrototypeEntered = false;\n\n                this.prototypeOut.emit({ item: prototype.item });\n\n                if (this.parent) {\n                    this.parent.enable();\n\n                    this.parent.isPrototypeEntered = true;\n                    if (\n                        this.parent.gridster.items.indexOf(prototype.item) < 0\n                    ) {\n                        this.parent.gridster.items.push(prototype.item);\n                    }\n                    this.parent.gridster.onStart(prototype.item);\n                    prototype.setDragContextGridster(this.parent.gridster);\n                    // timeout is needed to be sure that \"enter\" event is fired after \"out\"\n                    setTimeout(() => {\n                        this.parent.prototypeEnter.emit({\n                            item: prototype.item\n                        });\n                        prototype.onEnter(this.parent.gridster);\n                    });\n                }\n            });\n\n        dropOverObservable\n            .pipe(filter(() => !this.isDisabled))\n            .subscribe((data: any) => {\n                if (!this.isPrototypeEntered) {\n                    return;\n                }\n\n                this.gridster.onStop(data.item.item);\n                this.gridster.removeItem(data.item.item);\n\n                this.isPrototypeEntered = false;\n                if (this.parent) {\n                    this.parent.enable();\n                }\n                this.prototypeDrop.emit({ item: data.item.item });\n            });\n\n        dropOverObservable.connect();\n    }\n\n    private enableDraggable() {\n        this.gridster.options.dragAndDrop = true;\n\n        this.gridster.items\n            .filter(\n                item => item.itemComponent && item.itemComponent.dragAndDrop\n            )\n            .forEach((item: GridListItem) =>\n                item.itemComponent.enableDragDrop()\n            );\n    }\n\n    private disableDraggable() {\n        this.gridster.options.dragAndDrop = false;\n\n        this.gridster.items\n            .filter(item => item.itemComponent)\n            .forEach((item: GridListItem) =>\n                item.itemComponent.disableDraggable()\n            );\n    }\n\n    private enableResizable() {\n        this.gridster.options.resizable = true;\n\n        this.gridster.items\n            .filter(item => item.itemComponent && item.itemComponent.resizable)\n            .forEach((item: GridListItem) =>\n                item.itemComponent.enableResizable()\n            );\n    }\n\n    private disableResizable() {\n        this.gridster.options.resizable = false;\n\n        this.gridster.items.forEach((item: GridListItem) =>\n            item.itemComponent.disableResizable()\n        );\n    }\n}\n","import { GridsterItemComponent } from '../gridster-item/gridster-item.component';\nimport { GridsterItemPrototypeDirective } from '../gridster-prototype/gridster-item-prototype.directive';\nimport { GridsterService } from '../gridster.service';\n\nexport class GridListItem {\n    static BREAKPOINTS: Array<string> = ['sm', 'md', 'lg', 'xl'];\n    static X_PROPERTY_MAP: any = {\n        sm: 'xSm',\n        md: 'xMd',\n        lg: 'xLg',\n        xl: 'xXl'\n    };\n\n    static Y_PROPERTY_MAP: any = {\n        sm: 'ySm',\n        md: 'yMd',\n        lg: 'yLg',\n        xl: 'yXl'\n    };\n\n    static W_PROPERTY_MAP: any = {\n        sm: 'wSm',\n        md: 'wMd',\n        lg: 'wLg',\n        xl: 'wXl'\n    };\n\n    static H_PROPERTY_MAP: any = {\n        sm: 'hSm',\n        md: 'hMd',\n        lg: 'hLg',\n        xl: 'hXl'\n    };\n\n    itemComponent: GridsterItemComponent;\n    itemPrototype: GridsterItemPrototypeDirective;\n    itemObject: any;\n\n    get $element () {\n        return this.getItem().$element;\n    }\n\n    get x () {\n        const item = this.getItem();\n        const breakpoint = item.gridster ? item.gridster.options.breakpoint : null;\n\n        return this.getValueX(breakpoint);\n    }\n    set x (value: number) {\n        const item = this.getItem();\n        const breakpoint = item.gridster ? item.gridster.options.breakpoint : null;\n\n        this.setValueX(value, breakpoint);\n    }\n\n    get y () {\n        const item = this.getItem();\n        const breakpoint = item.gridster ? item.gridster.options.breakpoint : null;\n\n        return this.getValueY(breakpoint);\n    }\n    set y (value: number) {\n        const item = this.getItem();\n        const breakpoint = item.gridster ? item.gridster.options.breakpoint : null;\n\n        this.setValueY(value, breakpoint);\n    }\n\n    get w () {\n        const item = this.getItem();\n        const breakpoint = item.gridster ? item.gridster.options.breakpoint : null;\n\n        return this.getValueW(breakpoint);\n    }\n    set w (value: number) {\n        const item = this.getItem();\n        const breakpoint = item.gridster ? item.gridster.options.breakpoint : null;\n\n        this.setValueW(value, breakpoint);\n    }\n\n    get h () {\n        const item = this.getItem();\n        const breakpoint = item.gridster ? item.gridster.options.breakpoint : null;\n        return this.getValueH(breakpoint);\n    }\n    set h (value: number) {\n        const item = this.getItem();\n        const breakpoint = item.gridster ? item.gridster.options.breakpoint : null;\n\n        this.setValueH(value, breakpoint);\n    }\n\n    get autoSize () {\n        return this.getItem().autoSize;\n    }\n    set autoSize (value: boolean) {\n        this.getItem().autoSize = value;\n    }\n\n    get dragAndDrop() {\n        return !!this.getItem().dragAndDrop;\n    }\n\n    get resizable() {\n        return !!this.getItem().resizable;\n    }\n\n    get positionX() {\n        const item = this.itemComponent || this.itemPrototype;\n\n        if (!item) {\n            return null;\n        }\n\n        return item.positionX;\n    }\n\n    get positionY() {\n        const item = this.itemComponent || this.itemPrototype;\n\n        if (!item) {\n            return null;\n        }\n\n        return item.positionY;\n    }\n\n    get variableHeight(): boolean {\n        return this.getItem().variableHeight;\n    }\n\n    get contentHeight(): number {\n        // itemComponent is undefined when dragging a prototype\n        let contentHeight: number;\n        if (this.itemComponent) {\n            contentHeight = this.itemComponent.elementRef.nativeElement.offsetheight || 0;\n        } else {\n            contentHeight = 0;\n        }\n        const childHeight = this.$element.firstChild.offsetHeight || 0;\n        return Math.max(contentHeight, childHeight);\n    }\n\n    constructor () {}\n\n    public setFromGridsterItem (item: GridsterItemComponent): GridListItem {\n        if (this.isItemSet()) {\n            throw new Error('GridListItem is already set.');\n        }\n        this.itemComponent = item;\n        return this;\n    }\n\n    public setFromGridsterItemPrototype (item: GridsterItemPrototypeDirective): GridListItem {\n        if (this.isItemSet()) {\n            throw new Error('GridListItem is already set.');\n        }\n        this.itemPrototype = item;\n        return this;\n    }\n\n    public setFromObjectLiteral (item: Object): GridListItem {\n        if (this.isItemSet()) {\n            throw new Error('GridListItem is already set.');\n        }\n        this.itemObject = item;\n        return this;\n    }\n\n    public copy() {\n        const itemCopy = new GridListItem();\n\n        return itemCopy.setFromObjectLiteral({\n            $element: this.$element,\n            x: this.x,\n            y: this.y,\n            w: this.w,\n            h: this.h,\n            autoSize: this.autoSize,\n            dragAndDrop: this.dragAndDrop,\n            resizable: this.resizable\n        });\n    }\n\n    public copyForBreakpoint(breakpoint?: string) {\n        const itemCopy = new GridListItem();\n\n        return itemCopy.setFromObjectLiteral({\n            $element: this.$element,\n            x: this.getValueX(breakpoint),\n            y: this.getValueY(breakpoint),\n            w: this.getValueW(breakpoint),\n            h: this.getValueH(breakpoint),\n            autoSize: this.autoSize,\n            dragAndDrop: this.dragAndDrop,\n            resizable: this.resizable\n        });\n    }\n\n    public getValueX(breakpoint?: string) {\n        const item = this.getItem();\n\n        return item[this.getXProperty(breakpoint)];\n    }\n\n    public getValueY(breakpoint?: string) {\n        const item = this.getItem();\n\n        return item[this.getYProperty(breakpoint)];\n    }\n\n    public getValueW(breakpoint?: string) {\n        const item = this.getItem();\n\n        return item[this.getWProperty(breakpoint)] || 1;\n    }\n\n    public getValueH(breakpoint?: string) {\n        const item = this.getItem();\n\n        return item[this.getHProperty(breakpoint)] || 1;\n    }\n\n    public setValueX(value: number, breakpoint?: string) {\n        const item = this.getItem();\n\n        item[this.getXProperty(breakpoint)] = value;\n    }\n\n    public setValueY(value: number, breakpoint?: string) {\n        const item = this.getItem();\n\n        item[this.getYProperty(breakpoint)] = value;\n    }\n\n    public setValueW(value: number, breakpoint?: string) {\n        const item = this.getItem();\n\n        item[this.getWProperty(breakpoint)] = value;\n    }\n\n    public setValueH(value: number, breakpoint?: string) {\n        const item = this.getItem();\n\n        item[this.getHProperty(breakpoint)] = value;\n    }\n\n    public triggerChangeX(breakpoint?: string) {\n        const item = this.itemComponent;\n        if (item) {\n            (<any>item)[this.getXProperty(breakpoint) + 'Change'].emit(this.getValueX(breakpoint));\n        }\n    }\n\n    public triggerChangeY(breakpoint?: string) {\n        const item = this.itemComponent;\n        if (item) {\n            (<any>item)[this.getYProperty(breakpoint) + 'Change'].emit(this.getValueY(breakpoint));\n        }\n    }\n\n    public triggerChangeW(breakpoint?: string) {\n        const item = this.itemComponent;\n        if (item) {\n            (<any>item)[this.getWProperty(breakpoint) + 'Change'].emit(this.getValueW(breakpoint));\n        }\n    }\n\n    public triggerChangeH(breakpoint?: string) {\n        const item = this.itemComponent;\n        if (item) {\n            (<any>item)[this.getHProperty(breakpoint) + 'Change'].emit(this.getValueH(breakpoint));\n        }\n    }\n\n    public hasPositions(breakpoint?: string) {\n        const x = this.getValueX(breakpoint);\n        const y = this.getValueY(breakpoint);\n\n        return (x || x === 0) && (y || y === 0);\n    }\n\n    public applyPosition(gridster?: GridsterService) {\n        const position = this.calculatePosition(gridster);\n\n        this.itemComponent.positionX = position.left;\n        this.itemComponent.positionY = position.top;\n        this.itemComponent.updateElemenetPosition();\n    }\n\n    public calculatePosition(gridster?: GridsterService): {left: number, top: number} {\n        if (!gridster && !this.itemComponent) {\n            return {left: 0, top: 0};\n        }\n        gridster = gridster || this.itemComponent.gridster;\n\n        let top;\n        if (gridster.gridList) {\n            const rowHeights = gridster.getRowHeights();\n            const rowTops = gridster.getRowTops(rowHeights);\n            top = rowTops[this.y];\n        } else {\n            top = this.y * gridster.cellHeight;\n        }\n\n        return {\n            left: this.x * gridster.cellWidth,\n            top: top\n        };\n    }\n\n    public applySize(gridster?: GridsterService): void {\n        const size = this.calculateSize(gridster);\n\n        this.$element.style.width = size.width + 'px';\n        this.$element.style.height = size.height + 'px';\n    }\n\n    public calculateSize(gridster?: GridsterService): {width: number, height: number} {\n        if (!gridster && !this.itemComponent) {\n            return {width: 0, height: 0};\n        }\n        gridster = gridster || this.itemComponent.gridster;\n\n        let rowHeights, rowTops;\n        if (gridster.gridList) {\n            rowHeights = gridster.getRowHeights();\n            rowTops = gridster.getRowTops(rowHeights);\n        }\n\n        let width = this.w;\n        let height = this.h;\n\n        if (gridster.options.direction === 'vertical') {\n            width = Math.min(width, gridster.options.lanes);\n        }\n        if (gridster.options.direction === 'horizontal') {\n            height = Math.min(height, gridster.options.lanes);\n        }\n\n        let pixelHeight;\n        if (rowHeights) {\n            pixelHeight = 0;\n            for (let i = this.y; i < this.y + height; i++) {\n                pixelHeight += rowHeights[i];\n            }\n        } else {\n            pixelHeight = height * gridster.cellHeight;\n        }\n\n        return {\n            width: width * gridster.cellWidth,\n            height: pixelHeight\n        };\n    }\n\n    private getXProperty(breakpoint?: string) {\n\n        if (breakpoint && this.itemComponent) {\n            return GridListItem.X_PROPERTY_MAP[breakpoint];\n        } else {\n            return 'x';\n        }\n    }\n\n    private getYProperty(breakpoint?: string) {\n\n        if (breakpoint && this.itemComponent) {\n            return GridListItem.Y_PROPERTY_MAP[breakpoint];\n        } else {\n            return 'y';\n        }\n    }\n\n    private getWProperty(breakpoint?: string) {\n        if (this.itemPrototype) {\n            return (<any>this.itemPrototype)[GridListItem.W_PROPERTY_MAP[breakpoint]] ?\n                GridListItem.W_PROPERTY_MAP[breakpoint] : 'w';\n        }\n\n        const item = this.getItem();\n        const responsiveSizes = item.gridster && item.gridster.options.responsiveSizes;\n\n        if (breakpoint && responsiveSizes) {\n            return GridListItem.W_PROPERTY_MAP[breakpoint];\n        } else {\n            return 'w';\n        }\n    }\n\n    private getHProperty(breakpoint?: string) {\n        if (this.itemPrototype) {\n            return (<any>this.itemPrototype)[GridListItem.H_PROPERTY_MAP[breakpoint]] ?\n                GridListItem.H_PROPERTY_MAP[breakpoint] : 'h';\n        }\n\n        const item = this.getItem();\n        const responsiveSizes = item.gridster && item.gridster.options.responsiveSizes;\n\n        if (breakpoint && responsiveSizes) {\n            return GridListItem.H_PROPERTY_MAP[breakpoint];\n        } else {\n            return 'h';\n        }\n    }\n\n    private getItem(): any {\n        const item = this.itemComponent || this.itemPrototype || this.itemObject;\n\n        if (!item) {\n            throw new Error('GridListItem is not set.');\n        }\n        return item;\n    }\n\n    private isItemSet() {\n        return this.itemComponent || this.itemPrototype || this.itemObject;\n    }\n}\n","export class DraggableEvent {\n    clientX: number;\n\n    clientY: number;\n\n    pageX: number;\n\n    pageY: number;\n\n    target: any;\n\n    type: string;\n\n\n    private touchEvent: TouchEvent;\n\n    private mouseEvent: MouseEvent;\n\n    constructor(event: any) {\n        if (event.touches) {\n            this.touchEvent = (<TouchEvent>event);\n            this.setDataFromTouchEvent(this.touchEvent);\n        } else {\n            this.mouseEvent = (<MouseEvent>event);\n            this.setDataFromMouseEvent(this.mouseEvent);\n        }\n    }\n\n    isTouchEvent(): boolean {\n        return !!this.touchEvent;\n    }\n\n    pauseEvent() {\n        const event: Event = this.touchEvent || this.mouseEvent;\n\n        if (event.stopPropagation) {\n            event.stopPropagation();\n        }\n        if (event.preventDefault) {\n            event.preventDefault();\n        }\n        event.cancelBubble = true;\n        event.returnValue = false;\n        return false;\n    }\n\n    getRelativeCoordinates(container: HTMLElement): {x: number, y: number} {\n        const scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;\n\n        const rect = container.getBoundingClientRect();\n\n        return {\n            x: this.pageX - rect.left - scrollLeft,\n            y: this.pageY - rect.top - scrollTop,\n        };\n    }\n\n    private setDataFromMouseEvent(event: MouseEvent): void {\n        this.target = event.target;\n        this.clientX = event.clientX;\n        this.clientY = event.clientY;\n        this.pageX = event.pageX;\n        this.pageY = event.pageY;\n        this.type = event.type;\n    }\n\n    private setDataFromTouchEvent(event: TouchEvent): void {\n        const touch = event.touches[0] || event.changedTouches[0];\n\n        this.target = event.target;\n        this.clientX = touch.clientX;\n        this.clientY = touch.clientY;\n        this.pageX = touch.pageX;\n        this.pageY = touch.pageY;\n        this.type = event.type;\n\n    }\n}\n","import { Observable, fromEvent, merge, pipe } from 'rxjs';\nimport { share, map, filter, tap, switchMap, takeUntil, take, skip } from 'rxjs/operators';\n\nimport { DraggableEvent } from './DraggableEvent';\nimport { utils } from './utils';\n\nexport class Draggable {\n    static SCROLL_SPEED = 20;\n    element: Element;\n\n    dragStart: Observable<DraggableEvent>;\n    dragMove: Observable<DraggableEvent>;\n    dragStop: Observable<DraggableEvent>;\n    // A simple requestAnimationFrame polyfill\n    private requestAnimationFrame: Function;\n    private cancelAnimationFrame: Function;\n    private mousemove: Observable<{} | Event> = merge(\n        fromEvent(document, 'mousemove'),\n        fromEvent(document, 'touchmove', { passive: false })\n    ).pipe(share());\n    private mouseup: Observable<{} | Event> = merge(\n        fromEvent(document, 'mouseup'),\n        fromEvent(document, 'touchend'),\n        fromEvent(document, 'touchcancel')\n    ).pipe(share());\n    private mousedown: Observable<{} | Event>;\n    private config = {\n        handlerClass: <any>null,\n        scroll: true,\n        scrollEdge: 36,\n        scrollDirection: <any>null\n    };\n    // reference to auto scrolling listeners\n    private autoScrollingInterval: Function[] = [];\n\n    constructor(element: Element, config = {}) {\n        this.element = element;\n        this.mousedown = merge(\n            fromEvent(element, 'mousedown'),\n            fromEvent(element, 'touchstart')\n        ).pipe(share());\n\n        this.config = { ...this.config, ...config };\n\n        this.dragStart = this.createDragStartObservable().pipe(share());\n        this.dragMove = this.createDragMoveObservable(this.dragStart);\n        this.dragStop = this.createDragStopObservable(this.dragStart);\n\n        this.fixProblemWithDnDForIE(element);\n\n        this.requestAnimationFrame = window.requestAnimationFrame || ((callback: FrameRequestCallback) => setTimeout(callback, 1000 / 60));\n        this.cancelAnimationFrame = window.cancelAnimationFrame || ((cafID: number) => clearTimeout(cafID));\n    }\n\n    private createDragStartObservable(): Observable<DraggableEvent> {\n        return this.mousedown.pipe(\n            map(md => new DraggableEvent(md)),\n            filter((event: DraggableEvent) => this.isDragingByHandler(event)),\n            tap((e: DraggableEvent) => {\n                if (!e.isTouchEvent()) {\n                    e.pauseEvent();\n                }\n                if (document.activeElement) {\n                    (<any>document.activeElement).blur();\n                }\n                // prevents rendering performance issues while dragging item with selection inside\n                utils.clearSelection();\n            }),\n            switchMap((startEvent: DraggableEvent) => {\n                return this.mousemove.pipe(\n                    map(mm => new DraggableEvent(mm)),\n                    filter((moveEvent: DraggableEvent) => this.inRange(startEvent, moveEvent, 5)),\n                    map(() => startEvent),\n                    takeUntil(this.mouseup),\n                    take(1)\n                );\n            })\n        );\n    }\n\n    private createDragMoveObservable(\n        dragStart: Observable<DraggableEvent>\n    ): Observable<DraggableEvent> {\n        return dragStart.pipe(\n            tap((event: DraggableEvent) => {\n                this.addTouchActionNone(event.target);\n            }),\n            switchMap((startEvent: DraggableEvent) => {\n                return this.mousemove.pipe(\n                    skip(1),\n                    map(mm => new DraggableEvent(mm)),\n                    tap((event: DraggableEvent) => {\n                        event.pauseEvent();\n                        startEvent.pauseEvent();\n                    }),\n                    takeUntil(this.mouseup)\n                );\n            }),\n            filter(val => !!val),\n            tap((event: DraggableEvent) => {\n                if (this.config.scroll) {\n                    this.startScroll(this.element, event);\n                }\n            })\n        );\n    }\n\n    private createDragStopObservable(dragStart: Observable<DraggableEvent>): Observable<any> {\n        return dragStart.pipe(\n            switchMap(() => {\n                return this.mouseup.pipe(take(1));\n            }),\n            map(e => new DraggableEvent(e)),\n            tap((e: DraggableEvent) => {\n                if (e.target) {\n                    this.removeTouchActionNone(e.target);\n                }\n                this.autoScrollingInterval.forEach(raf => this.cancelAnimationFrame(raf));\n            })\n        );\n    }\n\n    private startScroll(item: Element, event: DraggableEvent) {\n        const scrollContainer = this.getScrollContainer(item);\n        this.autoScrollingInterval.forEach(raf => this.cancelAnimationFrame(raf));\n\n        if (scrollContainer) {\n            this.startScrollForContainer(event, scrollContainer);\n        } else {\n            this.startScrollForWindow(event);\n        }\n    }\n\n    private startScrollForContainer(event: DraggableEvent, scrollContainer: HTMLElement): void {\n        if (!this.config.scrollDirection || this.config.scrollDirection === 'vertical') {\n            this.startScrollVerticallyForContainer(event, scrollContainer);\n        }\n\n        if (!this.config.scrollDirection || this.config.scrollDirection === 'horizontal') {\n            this.startScrollHorizontallyForContainer(event, scrollContainer);\n        }\n    }\n\n    private startScrollVerticallyForContainer(\n        event: DraggableEvent,\n        scrollContainer: HTMLElement\n    ): void {\n        if (event.pageY - this.getOffset(scrollContainer).top < this.config.scrollEdge) {\n            this.startAutoScrolling(scrollContainer, -Draggable.SCROLL_SPEED, 'scrollTop');\n        } else if (\n            this.getOffset(scrollContainer).top +\n                scrollContainer.getBoundingClientRect().height -\n                event.pageY <\n            this.config.scrollEdge\n        ) {\n            this.startAutoScrolling(scrollContainer, Draggable.SCROLL_SPEED, 'scrollTop');\n        }\n    }\n\n    private startScrollHorizontallyForContainer(\n        event: DraggableEvent,\n        scrollContainer: HTMLElement\n    ): void {\n        if (event.pageX - scrollContainer.getBoundingClientRect().left < this.config.scrollEdge) {\n            this.startAutoScrolling(scrollContainer, -Draggable.SCROLL_SPEED, 'scrollLeft');\n        } else if (\n            this.getOffset(scrollContainer).left +\n                scrollContainer.getBoundingClientRect().width -\n                event.pageX <\n            this.config.scrollEdge\n        ) {\n            this.startAutoScrolling(scrollContainer, Draggable.SCROLL_SPEED, 'scrollLeft');\n        }\n    }\n\n    private startScrollForWindow(event: DraggableEvent) {\n\n        if (!this.config.scrollDirection || this.config.scrollDirection === 'vertical') {\n            this.startScrollVerticallyForWindow(event);\n        }\n\n        if (!this.config.scrollDirection || this.config.scrollDirection === 'horizontal') {\n            this.startScrollHorizontallyForWindow(event);\n        }\n    }\n\n    private startScrollVerticallyForWindow(event: DraggableEvent): void {\n        const scrollingElement =\n            document.scrollingElement || document.documentElement || document.body;\n\n        // NOTE: Using `window.pageYOffset` here because IE doesn't have `window.scrollY`.\n        if (event.pageY - window.pageYOffset < this.config.scrollEdge) {\n            this.startAutoScrolling(scrollingElement, -Draggable.SCROLL_SPEED, 'scrollTop');\n        } else if (\n            window.innerHeight - (event.pageY - window.pageYOffset) <\n            this.config.scrollEdge\n        ) {\n            this.startAutoScrolling(scrollingElement, Draggable.SCROLL_SPEED, 'scrollTop');\n        }\n    }\n\n    private startScrollHorizontallyForWindow(event: DraggableEvent): void {\n        const scrollingElement =\n            document.scrollingElement || document.documentElement || document.body;\n\n        // NOTE: Using `window.pageXOffset` here because IE doesn't have `window.scrollX`.\n        if (event.pageX - window.pageXOffset < this.config.scrollEdge) {\n            this.startAutoScrolling(scrollingElement, -Draggable.SCROLL_SPEED, 'scrollLeft');\n        } else if (\n            window.innerWidth - (event.pageX - window.pageXOffset) <\n            this.config.scrollEdge\n        ) {\n            this.startAutoScrolling(scrollingElement, Draggable.SCROLL_SPEED, 'scrollLeft');\n        }\n    }\n\n    private getScrollContainer(node: any): HTMLElement {\n        const nodeOuterHeight = utils.getElementOuterHeight(node);\n\n        if (node.scrollHeight > Math.ceil(nodeOuterHeight)) {\n            return node;\n        }\n\n        if (!new RegExp('(body|html)', 'i').test(node.parentNode.tagName)) {\n            return this.getScrollContainer(node.parentNode);\n        }\n\n        return null;\n    }\n\n    private startAutoScrolling(node: any, amount: number, direction: any) {\n        this.autoScrollingInterval.push(this.requestAnimationFrame(function() {\n            this.startAutoScrolling(node, amount, direction);\n        }.bind(this)));\n\n        return (node[direction] += amount * 0.25);\n    }\n\n    private getOffset(el: HTMLElement) {\n        const rect = el.getBoundingClientRect();\n        return {\n            left: rect.left + this.getScroll('scrollLeft', 'pageXOffset'),\n            top: rect.top + this.getScroll('scrollTop', 'pageYOffset')\n        };\n    }\n\n    private getScroll(scrollProp: keyof HTMLElement, offsetProp: keyof Window) {\n        if (typeof window[offsetProp] !== 'undefined') {\n            return window[offsetProp];\n        }\n        if (document.documentElement.clientHeight) {\n            return document.documentElement[scrollProp];\n        }\n        return document.body[scrollProp];\n    }\n\n    private isDragingByHandler(event: DraggableEvent): boolean {\n        if (!this.isValidDragHandler(event.target)) {\n            return false;\n        }\n\n        return (\n            !this.config.handlerClass ||\n            (this.config.handlerClass &&\n                this.hasElementWithClass(this.config.handlerClass, event.target))\n        );\n    }\n\n    private isValidDragHandler(targetEl: any): boolean {\n        return ['input', 'textarea'].indexOf(targetEl.tagName.toLowerCase()) === -1;\n    }\n\n    private inRange(startEvent: DraggableEvent, moveEvent: DraggableEvent, range: number): boolean {\n        return (\n            Math.abs(moveEvent.clientX - startEvent.clientX) > range ||\n            Math.abs(moveEvent.clientY - startEvent.clientY) > range\n        );\n    }\n\n    private hasElementWithClass(className: string, target: any): boolean {\n        while (target !== this.element) {\n            if (target.classList.contains(className)) {\n                return true;\n            }\n            target = target.parentElement;\n        }\n        return false;\n    }\n\n    public pauseEvent(e: Event): void {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        }\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n        e.cancelBubble = true;\n        e.returnValue = false;\n    }\n\n    private fixProblemWithDnDForIE(element: Element) {\n        if (this.isTouchDevice() && this.isIEorEdge() && (<HTMLElement>element).style) {\n            (<any>(<HTMLElement>element).style)['touch-action'] = 'none';\n        }\n    }\n\n    private removeTouchActionNone(element: Element) {\n        if (!(<HTMLElement>element).style) {\n            return;\n        }\n        (<any>(<HTMLElement>element).style)['touch-action'] = '';\n    }\n\n    private addTouchActionNone(element) {\n        if (!(<HTMLElement>element).style) {\n            return;\n        }\n        (<any>(<HTMLElement>element).style)['touch-action'] = 'none';\n    }\n\n    private isTouchDevice() {\n        return (\n            'ontouchstart' in window || navigator.maxTouchPoints // works on most browsers\n        ); // works on IE10/11 and Surface\n    }\n\n    private isIEorEdge() {\n        const ua = window.navigator.userAgent;\n\n        const msie = ua.indexOf('MSIE ');\n        if (msie > 0) {\n            // IE 10 or older => return version number\n            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n        }\n\n        const trident = ua.indexOf('Trident/');\n        if (trident > 0) {\n            // IE 11 => return version number\n            const rv = ua.indexOf('rv:');\n            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n        }\n\n        const edge = ua.indexOf('Edge/');\n        if (edge > 0) {\n            // Edge (IE 12+) => return version number\n            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n        }\n\n        // other browser\n        return false;\n    }\n}\n","import { Component, OnInit, ElementRef, Inject, Input, Output,\n    EventEmitter, SimpleChanges, OnChanges, OnDestroy, HostBinding,\n    ChangeDetectionStrategy, AfterViewInit, NgZone, ViewEncapsulation, ViewChild } from '@angular/core';\nimport { Subscription } from 'rxjs';\n\nimport { GridsterService } from '../gridster.service';\n\nimport { GridListItem } from '../gridList/GridListItem';\nimport { DraggableEvent } from '../utils/DraggableEvent';\nimport { Draggable } from '../utils/draggable';\nimport { IGridsterOptions } from '../IGridsterOptions';\nimport { GridList } from '../gridList/gridList';\nimport { utils } from '../utils/utils';\n\n@Component({\n    selector: 'ngx-gridster-item',\n    template: `<div class=\"gridster-item-inner\" [ngStyle]=\"{position: variableHeight ? 'relative' : ''}\">\n      <span #contentWrapper class=\"gridster-content-wrapper\">\n        <ng-content></ng-content>\n      </span>\n      <div class=\"gridster-item-resizable-handler handle-s\"></div>\n      <div class=\"gridster-item-resizable-handler handle-e\"></div>\n      <div class=\"gridster-item-resizable-handler handle-n\"></div>\n      <div class=\"gridster-item-resizable-handler handle-w\"></div>\n      <div class=\"gridster-item-resizable-handler handle-se\"></div>\n      <div class=\"gridster-item-resizable-handler handle-ne\"></div>\n      <div class=\"gridster-item-resizable-handler handle-sw\"></div>\n      <div class=\"gridster-item-resizable-handler handle-nw\"></div>\n    </div>`,\n    styles: [`\n    ngx-gridster-item {\n        display: block;\n        position: absolute;\n        top: 0;\n        left: 0;\n        z-index: 1;\n        -webkit-transition: none;\n        transition: none;\n    }\n\n    .gridster--ready ngx-gridster-item {\n        transition: all 200ms ease;\n        transition-property: left, top;\n    }\n\n    .gridster--ready.css-transform ngx-gridster-item  {\n        transition-property: transform;\n    }\n\n    .gridster--ready ngx-gridster-item.is-dragging,\n    .gridster--ready ngx-gridster-item.is-resizing {\n        -webkit-transition: none;\n        transition: none;\n        z-index: 9999;\n    }\n\n    ngx-gridster-item.no-transition {\n        -webkit-transition: none;\n        transition: none;\n    }\n    ngx-gridster-item .gridster-item-resizable-handler {\n        position: absolute;\n        z-index: 2;\n        display: none;\n    }\n\n    ngx-gridster-item .gridster-item-resizable-handler.handle-n {\n      cursor: n-resize;\n      height: 10px;\n      right: 0;\n      top: 0;\n      left: 0;\n    }\n\n    ngx-gridster-item .gridster-item-resizable-handler.handle-e {\n      cursor: e-resize;\n      width: 10px;\n      bottom: 0;\n      right: 0;\n      top: 0;\n    }\n\n    ngx-gridster-item .gridster-item-resizable-handler.handle-s {\n      cursor: s-resize;\n      height: 10px;\n      right: 0;\n      bottom: 0;\n      left: 0;\n    }\n\n    ngx-gridster-item .gridster-item-resizable-handler.handle-w {\n      cursor: w-resize;\n      width: 10px;\n      left: 0;\n      top: 0;\n      bottom: 0;\n    }\n\n    ngx-gridster-item .gridster-item-resizable-handler.handle-ne {\n      cursor: ne-resize;\n      width: 10px;\n      height: 10px;\n      right: 0;\n      top: 0;\n    }\n\n    ngx-gridster-item .gridster-item-resizable-handler.handle-nw {\n      cursor: nw-resize;\n      width: 10px;\n      height: 10px;\n      left: 0;\n      top: 0;\n    }\n\n    ngx-gridster-item .gridster-item-resizable-handler.handle-se {\n      cursor: se-resize;\n      width: 0;\n      height: 0;\n      right: 0;\n      bottom: 0;\n      border-style: solid;\n      border-width: 0 0 10px 10px;\n      border-color: transparent;\n    }\n\n    ngx-gridster-item .gridster-item-resizable-handler.handle-sw {\n      cursor: sw-resize;\n      width: 10px;\n      height: 10px;\n      left: 0;\n      bottom: 0;\n    }\n\n    ngx-gridster-item:hover .gridster-item-resizable-handler.handle-se {\n      border-color: transparent transparent #ccc\n    }\n    `],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None\n})\nexport class GridsterItemComponent implements OnInit, OnChanges, AfterViewInit, OnDestroy {\n    @Input() x: number;\n    @Output() xChange = new EventEmitter<number>(true);\n    @Input() y: number;\n    @Output() yChange = new EventEmitter<number>(true);\n\n    @Input() xSm: number;\n    @Output() xSmChange = new EventEmitter<number>(true);\n    @Input() ySm: number;\n    @Output() ySmChange = new EventEmitter<number>(true);\n\n    @Input() xMd: number;\n    @Output() xMdChange = new EventEmitter<number>(true);\n    @Input() yMd: number;\n    @Output() yMdChange = new EventEmitter<number>(true);\n\n    @Input() xLg: number;\n    @Output() xLgChange = new EventEmitter<number>(true);\n    @Input() yLg: number;\n    @Output() yLgChange = new EventEmitter<number>(true);\n\n    @Input() xXl: number;\n    @Output() xXlChange = new EventEmitter<number>(true);\n    @Input() yXl: number;\n    @Output() yXlChange = new EventEmitter<number>(true);\n\n\n    @Input() w: number;\n    @Output() wChange = new EventEmitter<number>(true);\n    @Input() h: number;\n    @Output() hChange = new EventEmitter<number>(true);\n\n    @Input() wSm: number;\n    @Output() wSmChange = new EventEmitter<number>(true);\n    @Input() hSm: number;\n    @Output() hSmChange = new EventEmitter<number>(true);\n\n    @Input() wMd: number;\n    @Output() wMdChange = new EventEmitter<number>(true);\n    @Input() hMd: number;\n    @Output() hMdChange = new EventEmitter<number>(true);\n\n    @Input() wLg: number;\n    @Output() wLgChange = new EventEmitter<number>(true);\n    @Input() hLg: number;\n    @Output() hLgChange = new EventEmitter<number>(true);\n\n    @Input() wXl: number;\n    @Output() wXlChange = new EventEmitter<number>(true);\n    @Input() hXl: number;\n    @Output() hXlChange = new EventEmitter<number>(true);\n\n    @Output() change = new EventEmitter<any>(true);\n    @Output() start = new EventEmitter<any>(true);\n    @Output() end = new EventEmitter<any>(true);\n\n    @Input() dragAndDrop = true;\n    @Input() resizable = true;\n\n    @Input() options: any = {};\n\n    @Input() variableHeight = false;\n\n    @ViewChild('contentWrapper') contentWrapper: ElementRef;\n\n    autoSize: boolean;\n\n    @HostBinding('class.is-dragging') isDragging = false;\n    @HostBinding('class.is-resizing') isResizing = false;\n\n    $element: HTMLElement;\n    elementRef: ElementRef;\n    /**\n     * Gridster provider service\n     */\n    gridster: GridsterService;\n\n    item: GridListItem;\n\n    set positionX(value: number) {\n        this._positionX = value;\n    }\n    get positionX() {\n        return this._positionX;\n    }\n    set positionY(value: number) {\n        this._positionY = value;\n    }\n    get positionY() {\n        return this._positionY;\n    }\n    private _positionX: number;\n    private _positionY: number;\n\n    private defaultOptions: any = {\n        minWidth: 1,\n        minHeight: 1,\n        maxWidth: Infinity,\n        maxHeight: Infinity,\n        defaultWidth: 1,\n        defaultHeight: 1\n    };\n    private subscriptions: Array<Subscription> = [];\n    private dragSubscriptions: Array<Subscription> = [];\n    private resizeSubscriptions: Array<Subscription> = [];\n\n    constructor(private zone: NgZone,\n                @Inject(ElementRef) elementRef: ElementRef,\n                @Inject(GridsterService) gridster: GridsterService) {\n\n        this.gridster = gridster;\n        this.elementRef = elementRef;\n        this.$element = elementRef.nativeElement;\n\n        this.item = (new GridListItem()).setFromGridsterItem(this);\n\n        // if gridster is initialized do not show animation on new grid-item construct\n        if (this.gridster.isInitialized()) {\n            this.preventAnimation();\n        }\n    }\n\n    ngOnInit() {\n        this.options = Object.assign(this.defaultOptions, this.options);\n\n        this.w = this.w || this.options.defaultWidth;\n        this.h = this.h || this.options.defaultHeight;\n        this.wSm = this.wSm || this.w;\n        this.hSm = this.hSm || this.h;\n        this.wMd = this.wMd || this.w;\n        this.hMd = this.hMd || this.h;\n        this.wLg = this.wLg || this.w;\n        this.hLg = this.hLg || this.h;\n        this.wXl = this.wXl || this.w;\n        this.hXl = this.hXl || this.h;\n\n        if (this.gridster.isInitialized()) {\n            this.setPositionsOnItem();\n        }\n\n        this.gridster.registerItem(this.item);\n\n        this.gridster.calculateCellSize();\n        this.item.applySize();\n        this.item.applyPosition();\n\n        if (this.gridster.options.dragAndDrop && this.dragAndDrop) {\n            this.enableDragDrop();\n        }\n\n        if (this.gridster.isInitialized()) {\n            this.gridster.render();\n            this.gridster.updateCachedItems();\n        }\n    }\n\n    ngAfterViewInit() {\n        if (this.gridster.options.resizable && this.item.resizable) {\n            this.enableResizable();\n        }\n\n        if (this.variableHeight) {\n            const readySubscription = this.gridster.gridsterComponent.ready.subscribe(() => {\n                this.gridster.gridList.resizeItem(this.item, { w: this.w, h: 1 });\n                readySubscription.unsubscribe();\n            });\n            let lastOffsetHeight: number;\n            const observer = new MutationObserver((mutations) => {\n                const offsetHeight = this.item.contentHeight;\n                if (offsetHeight !== lastOffsetHeight) {\n                    for (const item of this.gridster.items) {\n                        item.applySize();\n                        item.applyPosition();\n                    }\n                }\n                lastOffsetHeight = offsetHeight;\n            });\n            observer.observe(this.elementRef.nativeElement, {\n                childList: true,\n                subtree: true,\n                attributes: true,\n                characterData: true\n            });\n        }\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        if (!this.gridster.gridList) {\n            return;\n        }\n        let rerender = false;\n\n        ['w', ...Object.keys(GridListItem.W_PROPERTY_MAP).map(breakpoint => GridListItem.W_PROPERTY_MAP[breakpoint])]\n        .filter(propName => changes[propName] && !changes[propName].isFirstChange())\n        .forEach((propName: keyof GridsterItemComponent) => {\n            if (changes[propName].currentValue > this.options.maxWidth) {\n                // @ts-ignore\n                this[propName] = this.options.maxWidth;\n                setTimeout(() => this[<keyof GridsterItemComponent>(propName + 'Change')].emit(this[propName]));\n            }\n            rerender = true;\n        });\n\n        ['h', ...Object.keys(GridListItem.H_PROPERTY_MAP).map(breakpoint => GridListItem.H_PROPERTY_MAP[breakpoint])]\n            .filter(propName => changes[propName] && !changes[propName].isFirstChange())\n            .forEach((propName: keyof GridsterItemComponent) => {\n                if (changes[propName].currentValue > this.options.maxHeight) {\n                    // @ts-ignore\n                    this[propName] = this.options.maxHeight;\n                    setTimeout(() => this[<keyof GridsterItemComponent>(propName + 'Change')].emit(this[propName]));\n                }\n                rerender = true;\n            });\n\n        ['x', 'y',\n        ...Object.keys(GridListItem.X_PROPERTY_MAP).map(breakpoint => GridListItem.X_PROPERTY_MAP[breakpoint]),\n        ...Object.keys(GridListItem.Y_PROPERTY_MAP).map(breakpoint => GridListItem.Y_PROPERTY_MAP[breakpoint])]\n            .filter(propName => changes[propName] && !changes[propName].isFirstChange())\n            .forEach((propName: string) => rerender = true);\n\n        if (changes['dragAndDrop'] && !changes['dragAndDrop'].isFirstChange()) {\n            if (changes['dragAndDrop'].currentValue && this.gridster.options.dragAndDrop) {\n                this.enableDragDrop();\n            } else {\n                this.disableDraggable();\n            }\n        }\n        if (changes['resizable'] && !changes['resizable'].isFirstChange()) {\n            if (changes['resizable'].currentValue && this.gridster.options.resizable) {\n                this.enableResizable();\n            } else {\n                this.disableResizable();\n            }\n        }\n\n        if (rerender && this.gridster.gridsterComponent.isReady) {\n            this.gridster.debounceRenderSubject.next();\n        }\n    }\n\n    ngOnDestroy() {\n        this.gridster.removeItem(this.item);\n        this.gridster.itemRemoveSubject.next(this.item);\n\n        this.subscriptions.forEach((sub: Subscription) => {\n            sub.unsubscribe();\n        });\n        this.disableDraggable();\n        this.disableResizable();\n    }\n\n    updateElemenetPosition() {\n        if (this.gridster.options.useCSSTransforms) {\n            utils.setTransform(this.$element, {x: this._positionX, y: this._positionY});\n        } else {\n            utils.setCssElementPosition(this.$element, {x: this._positionX, y: this._positionY});\n        }\n    }\n\n    setPositionsOnItem() {\n        if (!this.item.hasPositions(this.gridster.options.breakpoint)) {\n            this.setPositionsForGrid(this.gridster.options);\n        }\n\n        this.gridster.gridsterOptions.responsiveOptions\n            .filter((options: IGridsterOptions) => !this.item.hasPositions(options.breakpoint))\n            .forEach((options: IGridsterOptions) => this.setPositionsForGrid(options));\n    }\n\n    public enableResizable() {\n        if (this.resizeSubscriptions.length) {\n            return;\n        }\n\n        this.zone.runOutsideAngular(() => {\n            this.getResizeHandlers().forEach((handler) => {\n                const direction = this.getResizeDirection(handler);\n\n                if (this.hasResizableHandle(direction)) {\n                    handler.style.display = 'block';\n                }\n\n                const draggable = new Draggable(handler, this.getResizableOptions());\n\n                let startEvent: DraggableEvent;\n                let startData: {\n                    top: number,\n                    left: number,\n                    height: number,\n                    width: number,\n                    minX: number,\n                    maxX: number,\n                    minY: number,\n                    maxY: number,\n                    minW: number,\n                    maxW: number,\n                    minH: number,\n                    maxH: number,\n                    scrollLeft: number,\n                    scrollTop: number\n                };\n                let cursorToElementPosition: { x: number, y: number };\n\n                const dragStartSub = draggable.dragStart\n                    .subscribe((event: DraggableEvent) => {\n                        this.zone.run(() => {\n                            this.isResizing = true;\n\n                            startEvent = event;\n                            startData = this.createResizeStartObject(direction);\n                            cursorToElementPosition = event.getRelativeCoordinates(this.$element);\n\n                            this.gridster.onResizeStart(this.item);\n                            this.onStart('resize');\n                        });\n                    });\n\n                const dragSub = draggable.dragMove\n                    .subscribe((event: DraggableEvent) => {\n                        const scrollData = this.gridster.gridsterScrollData;\n\n                        this.resizeElement({\n                            direction,\n                            startData,\n                            position: {\n                                x: event.clientX - cursorToElementPosition.x - this.gridster.gridsterRect.left,\n                                y: event.clientY - cursorToElementPosition.y - this.gridster.gridsterRect.top\n                            },\n                            startEvent,\n                            moveEvent: event,\n                            scrollDiffX: scrollData.scrollLeft - startData.scrollLeft,\n                            scrollDiffY: scrollData.scrollTop - startData.scrollTop\n                        });\n\n                        this.gridster.onResizeDrag(this.item);\n                    });\n\n                const dragStopSub = draggable.dragStop\n                    .subscribe(() => {\n                        this.zone.run(() => {\n                            this.isResizing = false;\n\n                            this.gridster.onResizeStop(this.item);\n                            this.onEnd('resize');\n                        });\n                    });\n\n                this.resizeSubscriptions = this.resizeSubscriptions.concat([dragStartSub, dragSub, dragStopSub]);\n\n            });\n        });\n    }\n\n    public disableResizable() {\n        this.resizeSubscriptions.forEach((sub: Subscription) => {\n            sub.unsubscribe();\n        });\n        this.resizeSubscriptions = [];\n\n        [].forEach.call(this.$element.querySelectorAll('.gridster-item-resizable-handler'), (handler: HTMLElement) => {\n            handler.style.display = '';\n        });\n    }\n\n    public enableDragDrop() {\n        if (this.dragSubscriptions.length) {\n            return;\n        }\n        this.zone.runOutsideAngular(() => {\n            let cursorToElementPosition: { x: number, y: number };\n\n            const draggable = new Draggable(this.$element, this.getDraggableOptions());\n\n            const dragStartSub = draggable.dragStart\n                .subscribe((event: DraggableEvent) => {\n                    this.zone.run(() => {\n                        this.gridster.onStart(this.item);\n                        this.isDragging = true;\n                        this.onStart('drag');\n\n                        cursorToElementPosition = event.getRelativeCoordinates(this.$element);\n                    });\n                });\n\n            const dragSub = draggable.dragMove\n                .subscribe((event: DraggableEvent) => {\n\n                    this.positionY = (event.clientY - cursorToElementPosition.y -\n                        this.gridster.gridsterRect.top);\n                    this.positionX = (event.clientX - cursorToElementPosition.x -\n                        this.gridster.gridsterRect.left);\n                    this.updateElemenetPosition();\n\n                    this.gridster.onDrag(this.item);\n                });\n\n            const dragStopSub = draggable.dragStop\n                .subscribe(() => {\n                    this.zone.run(() => {\n                        this.gridster.onStop(this.item);\n                        this.gridster.debounceRenderSubject.next();\n                        this.isDragging = false;\n                        this.onEnd('drag');\n                    });\n                });\n\n            this.dragSubscriptions = this.dragSubscriptions.concat([dragStartSub, dragSub, dragStopSub]);\n        });\n    }\n\n    public disableDraggable() {\n        this.dragSubscriptions.forEach((sub: Subscription) => {\n            sub.unsubscribe();\n        });\n        this.dragSubscriptions = [];\n    }\n\n    private getResizeHandlers(): HTMLElement[]  {\n        return [].filter.call(this.$element.children[0].children, (el: HTMLElement) => {\n\n            return el.classList.contains('gridster-item-resizable-handler');\n        });\n    }\n\n    private getDraggableOptions() {\n        return { scrollDirection: this.gridster.options.direction, ...this.gridster.draggableOptions };\n    }\n\n    private getResizableOptions() {\n        const resizableOptions: any = {};\n\n        if (this.gridster.draggableOptions.scroll || this.gridster.draggableOptions.scroll === false) {\n            resizableOptions.scroll = this.gridster.draggableOptions.scroll;\n        }\n        if (this.gridster.draggableOptions.scrollEdge) {\n            resizableOptions.scrollEdge = this.gridster.draggableOptions.scrollEdge;\n        }\n\n        resizableOptions.scrollDirection = this.gridster.options.direction;\n\n        return resizableOptions;\n    }\n\n    private hasResizableHandle(direction: string): boolean {\n        const isItemResizable = this.gridster.options.resizable && this.item.resizable;\n        const resizeHandles = this.gridster.options.resizeHandles;\n\n        return isItemResizable && (!resizeHandles || (resizeHandles && !!(<any>resizeHandles)[direction]));\n    }\n\n    private setPositionsForGrid(options: IGridsterOptions) {\n        let x, y;\n\n        const position = this.findPosition(options);\n        x = options.direction === 'horizontal' ? position[0] : position[1];\n        y = options.direction === 'horizontal' ? position[1] : position[0];\n\n        this.item.setValueX(x, options.breakpoint);\n        this.item.setValueY(y, options.breakpoint);\n\n        setTimeout(() => {\n            this.item.triggerChangeX(options.breakpoint);\n            this.item.triggerChangeY(options.breakpoint);\n        });\n    }\n\n    private findPosition(options: IGridsterOptions): Array<number> {\n        const gridList = new GridList(\n            this.gridster.items.map(item => item.copyForBreakpoint(options.breakpoint)),\n            options\n        );\n\n        return gridList.findPositionForItem(this.item, {x: 0, y: 0});\n    }\n\n    private createResizeStartObject(direction: string) {\n        const scrollData = this.gridster.gridsterScrollData;\n\n        return {\n            top: this.positionY,\n            left: this.positionX,\n            height: parseInt(this.$element.style.height, 10),\n            width: parseInt(this.$element.style.width, 10),\n            minX: Math.max(this.item.x + this.item.w - this.options.maxWidth, 0),\n            maxX: this.item.x + this.item.w - this.options.minWidth,\n            minY: Math.max(this.item.y + this.item.h - this.options.maxHeight, 0),\n            maxY: this.item.y + this.item.h - this.options.minHeight,\n            minW: this.options.minWidth,\n            maxW: Math.min(\n                this.options.maxWidth,\n                (this.gridster.options.direction === 'vertical' && direction.indexOf('w') < 0) ?\n                this.gridster.options.lanes - this.item.x : this.options.maxWidth,\n                direction.indexOf('w') >= 0 ?\n                this.item.x + this.item.w : this.options.maxWidth\n            ),\n            minH: this.options.minHeight,\n            maxH: Math.min(\n                this.options.maxHeight,\n                (this.gridster.options.direction === 'horizontal' && direction.indexOf('n') < 0) ?\n                this.gridster.options.lanes - this.item.y : this.options.maxHeight,\n                direction.indexOf('n') >= 0 ?\n                this.item.y + this.item.h : this.options.maxHeight\n            ),\n            scrollLeft: scrollData.scrollLeft,\n            scrollTop: scrollData.scrollTop\n        };\n    }\n\n    private onEnd(actionType: string): void {\n        this.end.emit({action: actionType, item: this.item});\n    }\n\n    private onStart(actionType: string): void {\n        this.start.emit({action: actionType, item: this.item});\n    }\n\n    /**\n     * Assign class for short while to prevent animation of grid item component\n     */\n    private preventAnimation(): GridsterItemComponent {\n        this.$element.classList.add('no-transition');\n        setTimeout(() => {\n            this.$element.classList.remove('no-transition');\n        }, 500);\n\n        return this;\n    }\n\n    private getResizeDirection(handler: Element): string {\n        for (let i = handler.classList.length - 1; i >= 0; i--) {\n            if (handler.classList[i].match('handle-')) {\n                return handler.classList[i].split('-')[1];\n            }\n        }\n    }\n\n    private resizeElement(config: any): void {\n        // north\n        if (config.direction.indexOf('n') >= 0) {\n            this.resizeToNorth(config);\n        }\n        // west\n        if (config.direction.indexOf('w') >= 0) {\n            this.resizeToWest(config);\n        }\n        // east\n        if (config.direction.indexOf('e') >= 0) {\n            this.resizeToEast(config);\n        }\n        // south\n        if (config.direction.indexOf('s') >= 0) {\n            this.resizeToSouth(config);\n        }\n    }\n\n    private resizeToNorth(config: any): void {\n        const height = config.startData.height + config.startEvent.clientY -\n            config.moveEvent.clientY - config.scrollDiffY;\n\n        if (height < (config.startData.minH * this.gridster.cellHeight)) {\n            this.setMinHeight('n', config);\n        } else if (height > (config.startData.maxH * this.gridster.cellHeight)) {\n            this.setMaxHeight('n', config);\n        } else {\n            this.positionY = config.position.y;\n            this.$element.style.height = height + 'px';\n        }\n    }\n\n    private resizeToWest(config: any): void {\n        const width = config.startData.width + config.startEvent.clientX -\n            config.moveEvent.clientX - config.scrollDiffX;\n\n        if (width < (config.startData.minW * this.gridster.cellWidth)) {\n            this.setMinWidth('w', config);\n        } else if (width > (config.startData.maxW * this.gridster.cellWidth)) {\n            this.setMaxWidth('w', config);\n        } else {\n            this.positionX = config.position.x;\n            this.updateElemenetPosition();\n            this.$element.style.width = width + 'px';\n        }\n    }\n\n    private resizeToEast(config: any): void {\n        const width = config.startData.width + config.moveEvent.clientX -\n            config.startEvent.clientX + config.scrollDiffX;\n\n        if (width > (config.startData.maxW * this.gridster.cellWidth)) {\n            this.setMaxWidth('e', config);\n        } else if (width < (config.startData.minW * this.gridster.cellWidth)) {\n            this.setMinWidth('e', config);\n        } else {\n            this.$element.style.width = width + 'px';\n        }\n    }\n\n    private resizeToSouth(config: any): void {\n        const height = config.startData.height + config.moveEvent.clientY -\n            config.startEvent.clientY + config.scrollDiffY;\n\n        if (height > config.startData.maxH * this.gridster.cellHeight) {\n            this.setMaxHeight('s', config);\n        } else if (height < config.startData.minH * this.gridster.cellHeight) {\n            this.setMinHeight('s', config);\n        } else {\n            this.$element.style.height = height + 'px';\n        }\n    }\n\n    private setMinHeight(direction: string, config: any): void {\n        if (direction === 'n') {\n            this.$element.style.height = (config.startData.minH * this.gridster.cellHeight) + 'px';\n            this.positionY = config.startData.maxY * this.gridster.cellHeight;\n        } else {\n            this.$element.style.height = (config.startData.minH * this.gridster.cellHeight) + 'px';\n        }\n    }\n\n    private setMinWidth(direction: string, config: any): void {\n        if (direction === 'w') {\n            this.$element.style.width = (config.startData.minW * this.gridster.cellWidth) + 'px';\n            this.positionX = config.startData.maxX * this.gridster.cellWidth;\n            this.updateElemenetPosition();\n        } else {\n            this.$element.style.width = (config.startData.minW * this.gridster.cellWidth) + 'px';\n        }\n    }\n\n    private setMaxHeight(direction: string, config: any): void {\n\n        if (direction === 'n') {\n            this.$element.style.height = (config.startData.maxH * this.gridster.cellHeight) + 'px';\n            this.positionY = config.startData.minY * this.gridster.cellHeight;\n        } else {\n            this.$element.style.height = (config.startData.maxH * this.gridster.cellHeight) + 'px';\n        }\n    }\n\n    private setMaxWidth(direction: string, config: any): void {\n\n        if (direction === 'w') {\n            this.$element.style.width = (config.startData.maxW * this.gridster.cellWidth) + 'px';\n            this.positionX = config.startData.minX * this.gridster.cellWidth;\n            this.updateElemenetPosition();\n        } else {\n            this.$element.style.width = (config.startData.maxW * this.gridster.cellWidth) + 'px';\n        }\n    }\n}\n","import { Directive, ElementRef, Input, Output, EventEmitter, OnInit, OnDestroy,\n    NgZone} from '@angular/core';\nimport { Observable, Subscription, fromEvent } from 'rxjs';\n\nimport { GridsterPrototypeService } from './gridster-prototype.service';\nimport { GridListItem } from '../gridList/GridListItem';\nimport { GridsterService } from '../gridster.service';\nimport { DraggableEvent } from '../utils/DraggableEvent';\nimport { Draggable } from '../utils/draggable';\nimport { utils } from '../utils/utils';\n\n@Directive({\n    selector: '[ngxGridsterItemPrototype]'\n})\nexport class GridsterItemPrototypeDirective implements OnInit, OnDestroy {\n    @Output() drop = new EventEmitter();\n    @Output() start = new EventEmitter();\n    @Output() cancel = new EventEmitter();\n    @Output() enter = new EventEmitter();\n    @Output() out = new EventEmitter();\n\n    @Input() data: any;\n    @Input() config: any = {};\n\n    public x = 0;\n    public y = 0;\n    @Input() w: number;\n    @Input() wSm: number;\n    @Input() wMd: number;\n    @Input() wLg: number;\n    @Input() wXl: number;\n    @Input() h: number;\n    @Input() hSm: number;\n    @Input() hMd: number;\n    @Input() hLg: number;\n    @Input() hXl: number;\n\n    @Input() variableHeight: boolean = false;\n    @Input() variableHeightContainToRow: boolean = false;\n\n    positionX: number;\n    positionY: number;\n\n    autoSize = false;\n\n    $element: HTMLElement;\n\n    /**\n     * Mouse drag observable\n     */\n    drag: Observable<any>;\n\n    /**\n     * Subscribtion for drag observable\n     */\n    dragSubscription: Subscription;\n\n    isDragging = false;\n\n    item: GridListItem;\n\n    containerRectange: ClientRect;\n\n    private dragContextGridster: GridsterService;\n    private parentRect: ClientRect;\n    private parentOffset: {left: number, top: number};\n\n    private subscribtions: Array<Subscription> = [];\n\n    // must be set to true because of item dragAndDrop configuration\n    get dragAndDrop(): boolean {\n        return true;\n    }\n\n    get gridster(): GridsterService {\n        return this.dragContextGridster;\n    }\n\n    constructor(private zone: NgZone,\n                private elementRef: ElementRef,\n                private gridsterPrototype: GridsterPrototypeService) {\n\n        this.item = (new GridListItem()).setFromGridsterItemPrototype(this);\n    }\n\n    ngOnInit() {\n        this.wSm = this.wSm || this.w;\n        this.hSm = this.hSm || this.h;\n        this.wMd = this.wMd || this.w;\n        this.hMd = this.hMd || this.h;\n        this.wLg = this.wLg || this.w;\n        this.hLg = this.hLg || this.h;\n        this.wXl = this.wXl || this.w;\n        this.hXl = this.hXl || this.h;\n        this.zone.runOutsideAngular(() => {\n            this.enableDragDrop();\n        });\n    }\n\n    ngOnDestroy() {\n        this.subscribtions.forEach((sub: Subscription) => {\n            sub.unsubscribe();\n        });\n    }\n\n    onDrop (gridster: GridsterService): void {\n        if (!this.config.helper) {\n            this.$element.parentNode.removeChild(this.$element);\n        }\n\n        this.drop.emit({\n            item: this.item,\n            gridster: gridster\n        });\n    }\n\n    onCancel (): void {\n        this.cancel.emit({item: this.item});\n    }\n\n    onEnter (gridster: GridsterService): void {\n        this.enter.emit({\n            item: this.item,\n            gridster: gridster\n        });\n    }\n\n    onOver (gridster: GridsterService): void {}\n\n    onOut (gridster: GridsterService): void {\n        this.out.emit({\n            item: this.item,\n            gridster: gridster\n        });\n    }\n\n    getPositionToGridster(gridster: GridsterService) {\n        const relativeContainerCoords = this.getContainerCoordsToGridster(gridster);\n\n        return {\n            y: this.positionY - relativeContainerCoords.top,\n            x: this.positionX - relativeContainerCoords.left\n        };\n    }\n\n    setDragContextGridster(gridster: GridsterService) {\n        this.dragContextGridster = gridster;\n    }\n\n    private getContainerCoordsToGridster(gridster: GridsterService): {top: number, left: number} {\n        return {\n            left: gridster.gridsterRect.left - this.parentRect.left,\n            top: gridster.gridsterRect.top - this.parentRect.top\n        };\n    }\n\n    private enableDragDrop() {\n        let cursorToElementPosition: { x: number, y: number };\n        const draggable = new Draggable(this.elementRef.nativeElement);\n\n        const dragStartSub = draggable.dragStart\n            .subscribe((event: DraggableEvent) => {\n                this.zone.run(() => {\n                    this.$element = this.provideDragElement();\n                    this.containerRectange = this.$element.parentElement.getBoundingClientRect();\n                    this.updateParentElementData();\n                    this.onStart(event);\n\n                    cursorToElementPosition = event.getRelativeCoordinates(this.$element);\n                });\n            });\n\n        const dragSub = draggable.dragMove\n            .subscribe((event: DraggableEvent) => {\n\n                this.setElementPosition(this.$element, {\n                    x: event.clientX - cursorToElementPosition.x  - this.parentRect.left,\n                    y: event.clientY - cursorToElementPosition.y  - this.parentRect.top\n                });\n\n                this.onDrag(event);\n            });\n\n        const dragStopSub = draggable.dragStop\n            .subscribe((event: DraggableEvent) => {\n                this.zone.run(() => {\n                    this.onStop(event);\n                    this.$element = null;\n                });\n            });\n\n        const scrollSub = fromEvent(document, 'scroll')\n            .subscribe(() => {\n                if (this.$element) {\n                    this.updateParentElementData();\n                }\n            });\n\n        this.subscribtions = this.subscribtions.concat([dragStartSub, dragSub, dragStopSub, scrollSub]);\n    }\n\n    private setElementPosition(element: HTMLElement, position: {x: number, y: number}) {\n        this.positionX = position.x;\n        this.positionY = position.y;\n        utils.setCssElementPosition(element, position);\n    }\n\n    private updateParentElementData() {\n        this.parentRect = this.$element.parentElement.getBoundingClientRect();\n        this.parentOffset = {\n            left: this.$element.parentElement.offsetLeft,\n            top: this.$element.parentElement.offsetTop\n        };\n    }\n\n    private onStart (event: DraggableEvent): void {\n        this.isDragging = true;\n\n        this.$element.style.pointerEvents = 'none';\n        this.$element.style.position = 'absolute';\n\n        this.gridsterPrototype.dragItemStart(this, event);\n\n        this.start.emit({item: this.item});\n    }\n\n    private onDrag (event: DraggableEvent): void {\n        this.gridsterPrototype.updatePrototypePosition(this, event);\n    }\n\n    private onStop (event: DraggableEvent): void {\n        this.gridsterPrototype.dragItemStop(this, event);\n\n        this.isDragging = false;\n        this.$element.style.pointerEvents = 'auto';\n        this.$element.style.position = '';\n        utils.resetCSSElementPosition(this.$element);\n\n        if (this.config.helper) {\n            this.$element.parentNode.removeChild(this.$element);\n        }\n    }\n\n    private provideDragElement (): HTMLElement {\n        let dragElement = this.elementRef.nativeElement;\n\n        if (this.config.helper) {\n            dragElement = <any>(dragElement).cloneNode(true);\n\n            document.body.appendChild(this.fixStylesForBodyHelper(dragElement));\n        } else {\n            this.fixStylesForRelativeElement(dragElement);\n        }\n\n        return dragElement;\n    }\n\n    private fixStylesForRelativeElement(el: HTMLElement) {\n        if (window.getComputedStyle(el).position === 'absolute') {\n            return el;\n        }\n        const rect = this.elementRef.nativeElement.getBoundingClientRect();\n        this.containerRectange = el.parentElement.getBoundingClientRect();\n\n        el.style.position = 'absolute';\n        this.setElementPosition(el, {\n            x: rect.left - this.containerRectange.left,\n            y: rect.top - this.containerRectange.top\n        });\n\n        return el;\n    }\n\n    /**\n     * When element is cloned and append to body it should have position absolute and coords set by original\n     * relative prototype element position.\n     */\n    private fixStylesForBodyHelper (el: HTMLElement) {\n        const bodyRect = document.body.getBoundingClientRect();\n        const rect = this.elementRef.nativeElement.getBoundingClientRect();\n\n        el.style.position = 'absolute';\n        this.setElementPosition(el, {\n            x: rect.left - bodyRect.left,\n            y: rect.top - bodyRect.top\n        });\n\n        return el;\n    }\n\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { GridsterComponent } from './gridster.component';\nimport { GridsterItemComponent } from './gridster-item/gridster-item.component';\nimport { GridsterItemPrototypeDirective } from './gridster-prototype/gridster-item-prototype.directive';\nimport { GridsterPrototypeService } from './gridster-prototype/gridster-prototype.service';\n\n@NgModule({\n    imports: [\n        CommonModule\n    ],\n    declarations: [\n        GridsterComponent,\n        GridsterItemComponent,\n        GridsterItemPrototypeDirective\n    ],\n    exports: [\n        GridsterComponent,\n        GridsterItemComponent,\n        GridsterItemPrototypeDirective\n    ]\n})\nexport class GridsterModule {\n    static forRoot(): ModuleWithProviders<GridsterModule> {\n    return {\n        ngModule: GridsterModule,\n        providers: [GridsterPrototypeService]\n    };\n}\n}\n\n"]}