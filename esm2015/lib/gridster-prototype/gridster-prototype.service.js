import { __decorate, __metadata } from "tslib";
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, switchMap, map, scan, filter, share, tap } from 'rxjs/operators';
import { utils } from '../utils/utils';
import { merge } from 'rxjs';
let GridsterPrototypeService = class GridsterPrototypeService {
    constructor() {
        this.isDragging = false;
        this.dragSubject = new Subject();
        this.dragStartSubject = new Subject();
        this.dragStopSubject = new Subject();
    }
    observeDropOver(gridster) {
        return this.dragStopSubject.pipe(filter((data) => {
            const gridsterEl = gridster.gridsterComponent.$element;
            const isOverNestedGridster = [].slice.call(gridsterEl.querySelectorAll('gridster'))
                .reduce((isOverGridster, nestedGridsterEl) => {
                return isOverGridster ||
                    this.isOverGridster(data.item, nestedGridsterEl, data.event, gridster.options);
            }, false);
            if (isOverNestedGridster) {
                return false;
            }
            return this.isOverGridster(data.item, gridsterEl, data.event, gridster.options);
        }), tap((data) => {
            // TODO: what we should provide as a param?
            // prototype.drop.emit({item: prototype.item});
            data.item.onDrop(gridster);
        }));
    }
    observeDropOut(gridster) {
        return this.dragStopSubject.pipe(filter((data) => {
            const gridsterEl = gridster.gridsterComponent.$element;
            return !this.isOverGridster(data.item, gridsterEl, data.event, gridster.options);
        }), tap((data) => {
            // TODO: what we should provide as a param?
            data.item.onCancel();
        }));
    }
    observeDragOver(gridster) {
        const over = this.dragSubject.pipe(map((data) => {
            const gridsterEl = gridster.gridsterComponent.$element;
            return {
                item: data.item,
                event: data.event,
                isOver: this.isOverGridster(data.item, gridsterEl, data.event, gridster.options),
                isDrop: false
            };
        }));
        const drop = this.dragStopSubject.pipe(map((data) => {
            const gridsterEl = gridster.gridsterComponent.$element;
            return {
                item: data.item,
                event: data.event,
                isOver: this.isOverGridster(data.item, gridsterEl, data.event, gridster.options),
                isDrop: true
            };
        }));
        const dragExt = merge(
        // dragStartSubject is connected in case when item prototype is placed above gridster
        // and drag enter is not fired
        this.dragStartSubject.pipe(map(() => ({ item: null, isOver: false, isDrop: false }))), over, drop).pipe(scan((prev, next) => {
            return {
                item: next.item,
                event: next.event,
                isOver: next.isOver,
                isEnter: prev.isOver === false && next.isOver === true,
                isOut: prev.isOver === true && next.isOver === false && !prev.isDrop,
                isDrop: next.isDrop
            };
        }), filter((data) => {
            return !data.isDrop;
        }), share());
        const dragEnter = this.createDragEnterObservable(dragExt, gridster);
        const dragOut = this.createDragOutObservable(dragExt, gridster);
        const dragOver = dragEnter
            .pipe(switchMap(() => this.dragSubject.pipe(takeUntil(dragOut))), map((data) => data.item));
        return { dragEnter, dragOut, dragOver };
    }
    dragItemStart(item, event) {
        this.isDragging = true;
        this.dragStartSubject.next({ item, event });
    }
    dragItemStop(item, event) {
        this.isDragging = false;
        this.dragStopSubject.next({ item, event });
    }
    updatePrototypePosition(item, event) {
        this.dragSubject.next({ item, event });
    }
    /**
     * Creates observable that is fired on dragging over gridster container.
     */
    createDragOverObservable(dragIsOver, gridster) {
        return dragIsOver.pipe(filter((data) => data.isOver && !data.isEnter && !data.isOut), map((data) => data.item), tap((item) => item.onOver(gridster)));
    }
    /**
     * Creates observable that is fired on drag enter gridster container.
     */
    createDragEnterObservable(dragIsOver, gridster) {
        return dragIsOver.pipe(filter((data) => data.isEnter), map((data) => data.item), tap((item) => item.onEnter(gridster)));
    }
    /**
     * Creates observable that is fired on drag out gridster container.
     */
    createDragOutObservable(dragIsOver, gridster) {
        return dragIsOver.pipe(filter((data) => data.isOut), map((data) => data.item), tap((item) => item.onOut(gridster)));
    }
    /**
     * Checks whether "element" position fits inside "containerEl" position.
     * It checks if "element" is totally covered by "containerEl" area.
     */
    isOverGridster(item, gridsterEl, event, options) {
        const el = item.$element;
        const parentItem = gridsterEl.parentElement &&
            gridsterEl.parentElement.closest('gridster-item');
        if (parentItem) {
            return this.isOverGridster(item, parentItem, event, options);
        }
        switch (options.tolerance) {
            case 'fit':
                return utils.isElementFitContainer(el, gridsterEl);
            case 'intersect':
                return utils.isElementIntersectContainer(el, gridsterEl);
            case 'touch':
                return utils.isElementTouchContainer(el, gridsterEl);
            default:
                return utils.isCursorAboveElement(event, gridsterEl);
        }
    }
};
GridsterPrototypeService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], GridsterPrototypeService);
export { GridsterPrototypeService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZHN0ZXItcHJvdG90eXBlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyMmdyaWRzdGVyLyIsInNvdXJjZXMiOlsibGliL2dyaWRzdGVyLXByb3RvdHlwZS9ncmlkc3Rlci1wcm90b3R5cGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUlyRixPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdkMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUc3QixJQUFhLHdCQUF3QixHQUFyQyxNQUFhLHdCQUF3QjtJQVVqQztRQVJRLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFFbkIsZ0JBQVcsR0FBRyxJQUFJLE9BQU8sRUFBTyxDQUFDO1FBRWpDLHFCQUFnQixHQUFHLElBQUksT0FBTyxFQUFPLENBQUM7UUFFdEMsb0JBQWUsR0FBRyxJQUFJLE9BQU8sRUFBTyxDQUFDO0lBRTlCLENBQUM7SUFFaEIsZUFBZSxDQUFFLFFBQXlCO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQzVCLE1BQU0sQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFO1lBQ2pCLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUM7WUFDdkQsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQzlFLE1BQU0sQ0FBQyxDQUFDLGNBQXVCLEVBQUUsZ0JBQTZCLEVBQUUsRUFBRTtnQkFDL0QsT0FBTyxjQUFjO29CQUNqQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDdkYsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRWQsSUFBSSxvQkFBb0IsRUFBRTtnQkFDdEIsT0FBTyxLQUFLLENBQUM7YUFDaEI7WUFFRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEYsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLENBQUMsSUFBUyxFQUFFLEVBQUU7WUFDZCwyQ0FBMkM7WUFDM0MsK0NBQStDO1lBQy9DLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9CLENBQUMsQ0FBQyxDQUNMLENBQUM7SUFDTixDQUFDO0lBRUQsY0FBYyxDQUFFLFFBQXlCO1FBQ3JDLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQzVCLE1BQU0sQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFO1lBQ2pCLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUM7WUFFdkQsT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDckYsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLENBQUMsSUFBUyxFQUFFLEVBQUU7WUFDZCwyQ0FBMkM7WUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN6QixDQUFDLENBQUMsQ0FDTCxDQUFDO0lBQ04sQ0FBQztJQUVELGVBQWUsQ0FBQyxRQUF5QjtRQUtyQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FDOUIsR0FBRyxDQUFDLENBQUMsSUFBUyxFQUFFLEVBQUU7WUFDZCxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDO1lBRXZELE9BQU87Z0JBQ0wsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2dCQUNmLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztnQkFDakIsTUFBTSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDO2dCQUNoRixNQUFNLEVBQUUsS0FBSzthQUNkLENBQUM7UUFDTixDQUFDLENBQUMsQ0FDTCxDQUFDO1FBRUYsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQ2xDLEdBQUcsQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFO1lBQ2QsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQztZQUV2RCxPQUFPO2dCQUNILElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtnQkFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7Z0JBQ2pCLE1BQU0sRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQztnQkFDaEYsTUFBTSxFQUFFLElBQUk7YUFDZixDQUFDO1FBQ04sQ0FBQyxDQUFDLENBQ0wsQ0FBQztRQUVGLE1BQU0sT0FBTyxHQUFHLEtBQUs7UUFDYixxRkFBcUY7UUFDckYsOEJBQThCO1FBQzlCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUNyRixJQUFJLEVBQ0osSUFBSSxDQUNQLENBQUMsSUFBSSxDQUNGLElBQUksQ0FBQyxDQUFDLElBQVMsRUFBRSxJQUFTLEVBQUUsRUFBRTtZQUMxQixPQUFPO2dCQUNILElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtnQkFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7Z0JBQ2pCLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtnQkFDbkIsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssSUFBSTtnQkFDdEQsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU07Z0JBQ3BFLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTthQUN0QixDQUFDO1FBQ04sQ0FBQyxDQUFDLEVBQ0YsTUFBTSxDQUFDLENBQUMsSUFBUyxFQUFFLEVBQUU7WUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDeEIsQ0FBQyxDQUFDLEVBQ0YsS0FBSyxFQUFFLENBQ1YsQ0FBQztRQUVOLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDcEUsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNoRSxNQUFNLFFBQVEsR0FBRyxTQUFTO2FBQ3JCLElBQUksQ0FDRCxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFDMUQsR0FBRyxDQUFDLENBQUMsSUFBUyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ2hDLENBQUM7UUFFTixPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQsYUFBYSxDQUFDLElBQW9DLEVBQUUsS0FBcUI7UUFDckUsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7UUFDdkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCxZQUFZLENBQUMsSUFBb0MsRUFBRSxLQUFxQjtRQUNwRSxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRCx1QkFBdUIsQ0FBQyxJQUFvQyxFQUFFLEtBQXFCO1FBQy9FLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOztPQUVHO0lBQ0ksd0JBQXdCLENBQzNCLFVBQStFLEVBQy9FLFFBQXlCO1FBRXpCLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FDbEIsTUFBTSxDQUFDLENBQUMsSUFBUyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFDbEUsR0FBRyxDQUFDLENBQUMsSUFBUyxFQUFrQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUM3RCxHQUFHLENBQUMsQ0FBQyxJQUFvQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQ3ZFLENBQUM7SUFDTixDQUFDO0lBQ0Q7O09BRUc7SUFDSyx5QkFBeUIsQ0FDN0IsVUFBK0UsRUFDL0UsUUFBeUI7UUFFekIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUNsQixNQUFNLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFDbkMsR0FBRyxDQUFDLENBQUMsSUFBUyxFQUFrQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUM3RCxHQUFHLENBQUMsQ0FBQyxJQUFvQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQ3hFLENBQUM7SUFDTixDQUFDO0lBQ0Q7O09BRUc7SUFDSyx1QkFBdUIsQ0FDM0IsVUFDaUIsRUFDakIsUUFBeUI7UUFFekIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUNsQixNQUFNLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFDakMsR0FBRyxDQUFDLENBQUMsSUFBUyxFQUFrQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUM3RCxHQUFHLENBQUMsQ0FBQyxJQUFvQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQ3RFLENBQUM7SUFDTixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssY0FBYyxDQUFDLElBQW9DLEVBQUUsVUFBdUIsRUFBRSxLQUFVLEVBQUUsT0FBWTtRQUMxRyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3pCLE1BQU0sVUFBVSxHQUFnQixVQUFVLENBQUMsYUFBYTtZQUN2QyxVQUFVLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUVuRSxJQUFJLFVBQVUsRUFBRTtZQUNaLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNoRTtRQUVELFFBQVEsT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUN2QixLQUFLLEtBQUs7Z0JBQ04sT0FBTyxLQUFLLENBQUMscUJBQXFCLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQ3ZELEtBQUssV0FBVztnQkFDWixPQUFPLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDN0QsS0FBSyxPQUFPO2dCQUNSLE9BQU8sS0FBSyxDQUFDLHVCQUF1QixDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUN6RDtnQkFDSSxPQUFPLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDNUQ7SUFDTCxDQUFDO0NBQ0osQ0FBQTtBQWxNWSx3QkFBd0I7SUFEcEMsVUFBVSxFQUFFOztHQUNBLHdCQUF3QixDQWtNcEM7U0FsTVksd0JBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCBzd2l0Y2hNYXAsIG1hcCwgc2NhbiwgZmlsdGVyLCBzaGFyZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBHcmlkc3RlclNlcnZpY2UgfSBmcm9tICcuLi9ncmlkc3Rlci5zZXJ2aWNlJztcbmltcG9ydCB7IEdyaWRzdGVySXRlbVByb3RvdHlwZURpcmVjdGl2ZSB9IGZyb20gJy4vZ3JpZHN0ZXItaXRlbS1wcm90b3R5cGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IHV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHtEcmFnZ2FibGVFdmVudH0gZnJvbSAnLi4vdXRpbHMvRHJhZ2dhYmxlRXZlbnQnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEdyaWRzdGVyUHJvdG90eXBlU2VydmljZSB7XG5cbiAgICBwcml2YXRlIGlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgZHJhZ1N1YmplY3QgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICBwcml2YXRlIGRyYWdTdGFydFN1YmplY3QgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICBwcml2YXRlIGRyYWdTdG9wU3ViamVjdCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKCkge31cblxuICAgIG9ic2VydmVEcm9wT3ZlciAoZ3JpZHN0ZXI6IEdyaWRzdGVyU2VydmljZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU3RvcFN1YmplY3QucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoZGF0YTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JpZHN0ZXJFbCA9IGdyaWRzdGVyLmdyaWRzdGVyQ29tcG9uZW50LiRlbGVtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT3Zlck5lc3RlZEdyaWRzdGVyID0gW10uc2xpY2UuY2FsbChncmlkc3RlckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2dyaWRzdGVyJykpXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGlzT3ZlckdyaWRzdGVyOiBib29sZWFuLCBuZXN0ZWRHcmlkc3RlckVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzT3ZlckdyaWRzdGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc092ZXJHcmlkc3RlcihkYXRhLml0ZW0sIG5lc3RlZEdyaWRzdGVyRWwsIGRhdGEuZXZlbnQsIGdyaWRzdGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPdmVyTmVzdGVkR3JpZHN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT3ZlckdyaWRzdGVyKGRhdGEuaXRlbSwgZ3JpZHN0ZXJFbCwgZGF0YS5ldmVudCwgZ3JpZHN0ZXIub3B0aW9ucyk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRhcCgoZGF0YTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2hhdCB3ZSBzaG91bGQgcHJvdmlkZSBhcyBhIHBhcmFtP1xuICAgICAgICAgICAgICAgIC8vIHByb3RvdHlwZS5kcm9wLmVtaXQoe2l0ZW06IHByb3RvdHlwZS5pdGVtfSk7XG4gICAgICAgICAgICAgICAgZGF0YS5pdGVtLm9uRHJvcChncmlkc3Rlcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG9ic2VydmVEcm9wT3V0IChncmlkc3RlcjogR3JpZHN0ZXJTZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdTdG9wU3ViamVjdC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBncmlkc3RlckVsID0gZ3JpZHN0ZXIuZ3JpZHN0ZXJDb21wb25lbnQuJGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNPdmVyR3JpZHN0ZXIoZGF0YS5pdGVtLCBncmlkc3RlckVsLCBkYXRhLmV2ZW50LCBncmlkc3Rlci5vcHRpb25zKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGFwKChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGF0IHdlIHNob3VsZCBwcm92aWRlIGFzIGEgcGFyYW0/XG4gICAgICAgICAgICAgICAgZGF0YS5pdGVtLm9uQ2FuY2VsKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG9ic2VydmVEcmFnT3Zlcihncmlkc3RlcjogR3JpZHN0ZXJTZXJ2aWNlKToge1xuICAgICAgICBkcmFnT3ZlcjogT2JzZXJ2YWJsZTxHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmU+LFxuICAgICAgICBkcmFnRW50ZXI6IE9ic2VydmFibGU8R3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlPixcbiAgICAgICAgZHJhZ091dDogT2JzZXJ2YWJsZTxHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmU+XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IG92ZXIgPSB0aGlzLmRyYWdTdWJqZWN0LnBpcGUoXG4gICAgICAgICAgICBtYXAoKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyaWRzdGVyRWwgPSBncmlkc3Rlci5ncmlkc3RlckNvbXBvbmVudC4kZWxlbWVudDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBpdGVtOiBkYXRhLml0ZW0sXG4gICAgICAgICAgICAgICAgICBldmVudDogZGF0YS5ldmVudCxcbiAgICAgICAgICAgICAgICAgIGlzT3ZlcjogdGhpcy5pc092ZXJHcmlkc3RlcihkYXRhLml0ZW0sIGdyaWRzdGVyRWwsIGRhdGEuZXZlbnQsIGdyaWRzdGVyLm9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgaXNEcm9wOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGRyb3AgPSB0aGlzLmRyYWdTdG9wU3ViamVjdC5waXBlKFxuICAgICAgICAgICAgbWFwKChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBncmlkc3RlckVsID0gZ3JpZHN0ZXIuZ3JpZHN0ZXJDb21wb25lbnQuJGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtOiBkYXRhLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBkYXRhLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpc092ZXI6IHRoaXMuaXNPdmVyR3JpZHN0ZXIoZGF0YS5pdGVtLCBncmlkc3RlckVsLCBkYXRhLmV2ZW50LCBncmlkc3Rlci5vcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgaXNEcm9wOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZHJhZ0V4dCA9IG1lcmdlKFxuICAgICAgICAgICAgICAgIC8vIGRyYWdTdGFydFN1YmplY3QgaXMgY29ubmVjdGVkIGluIGNhc2Ugd2hlbiBpdGVtIHByb3RvdHlwZSBpcyBwbGFjZWQgYWJvdmUgZ3JpZHN0ZXJcbiAgICAgICAgICAgICAgICAvLyBhbmQgZHJhZyBlbnRlciBpcyBub3QgZmlyZWRcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydFN1YmplY3QucGlwZShtYXAoKCkgPT4gKHsgaXRlbTogbnVsbCwgaXNPdmVyOiBmYWxzZSwgaXNEcm9wOiBmYWxzZSB9KSkpLFxuICAgICAgICAgICAgICAgIG92ZXIsXG4gICAgICAgICAgICAgICAgZHJvcFxuICAgICAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgICAgIHNjYW4oKHByZXY6IGFueSwgbmV4dDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBuZXh0Lml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV4dC5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3ZlcjogbmV4dC5pc092ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VudGVyOiBwcmV2LmlzT3ZlciA9PT0gZmFsc2UgJiYgbmV4dC5pc092ZXIgPT09IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc091dDogcHJldi5pc092ZXIgPT09IHRydWUgJiYgbmV4dC5pc092ZXIgPT09IGZhbHNlICYmICFwcmV2LmlzRHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcDogbmV4dC5pc0Ryb3BcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXIoKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRhdGEuaXNEcm9wO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHNoYXJlKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZHJhZ0VudGVyID0gdGhpcy5jcmVhdGVEcmFnRW50ZXJPYnNlcnZhYmxlKGRyYWdFeHQsIGdyaWRzdGVyKTtcbiAgICAgICAgY29uc3QgZHJhZ091dCA9IHRoaXMuY3JlYXRlRHJhZ091dE9ic2VydmFibGUoZHJhZ0V4dCwgZ3JpZHN0ZXIpO1xuICAgICAgICBjb25zdCBkcmFnT3ZlciA9IGRyYWdFbnRlclxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMuZHJhZ1N1YmplY3QucGlwZSh0YWtlVW50aWwoZHJhZ091dCkpKSxcbiAgICAgICAgICAgICAgICBtYXAoKGRhdGE6IGFueSkgPT4gZGF0YS5pdGVtKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4geyBkcmFnRW50ZXIsIGRyYWdPdXQsIGRyYWdPdmVyIH07XG4gICAgfVxuXG4gICAgZHJhZ0l0ZW1TdGFydChpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUsIGV2ZW50OiBEcmFnZ2FibGVFdmVudCkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRyYWdTdGFydFN1YmplY3QubmV4dCh7IGl0ZW0sIGV2ZW50IH0pO1xuICAgIH1cblxuICAgIGRyYWdJdGVtU3RvcChpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUsIGV2ZW50OiBEcmFnZ2FibGVFdmVudCkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnU3RvcFN1YmplY3QubmV4dCh7IGl0ZW0sIGV2ZW50IH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZVByb3RvdHlwZVBvc2l0aW9uKGl0ZW06IEdyaWRzdGVySXRlbVByb3RvdHlwZURpcmVjdGl2ZSwgZXZlbnQ6IERyYWdnYWJsZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuZHJhZ1N1YmplY3QubmV4dCh7IGl0ZW0sIGV2ZW50IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb2JzZXJ2YWJsZSB0aGF0IGlzIGZpcmVkIG9uIGRyYWdnaW5nIG92ZXIgZ3JpZHN0ZXIgY29udGFpbmVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVEcmFnT3Zlck9ic2VydmFibGUgKFxuICAgICAgICBkcmFnSXNPdmVyOiBPYnNlcnZhYmxlPHtpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUsIGlzT3ZlcjogYm9vbGVhbn0+LFxuICAgICAgICBncmlkc3RlcjogR3JpZHN0ZXJTZXJ2aWNlXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBkcmFnSXNPdmVyLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKGRhdGE6IGFueSkgPT4gZGF0YS5pc092ZXIgJiYgIWRhdGEuaXNFbnRlciAmJiAhZGF0YS5pc091dCksXG4gICAgICAgICAgICBtYXAoKGRhdGE6IGFueSk6IEdyaWRzdGVySXRlbVByb3RvdHlwZURpcmVjdGl2ZSA9PiBkYXRhLml0ZW0pLFxuICAgICAgICAgICAgdGFwKChpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUpID0+IGl0ZW0ub25PdmVyKGdyaWRzdGVyKSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvYnNlcnZhYmxlIHRoYXQgaXMgZmlyZWQgb24gZHJhZyBlbnRlciBncmlkc3RlciBjb250YWluZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjcmVhdGVEcmFnRW50ZXJPYnNlcnZhYmxlIChcbiAgICAgICAgZHJhZ0lzT3ZlcjogT2JzZXJ2YWJsZTx7aXRlbTogR3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlLCBpc092ZXI6IGJvb2xlYW59PixcbiAgICAgICAgZ3JpZHN0ZXI6IEdyaWRzdGVyU2VydmljZVxuICAgICkge1xuICAgICAgICByZXR1cm4gZHJhZ0lzT3Zlci5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKChkYXRhOiBhbnkpID0+IGRhdGEuaXNFbnRlciksXG4gICAgICAgICAgICBtYXAoKGRhdGE6IGFueSk6IEdyaWRzdGVySXRlbVByb3RvdHlwZURpcmVjdGl2ZSA9PiBkYXRhLml0ZW0pLFxuICAgICAgICAgICAgdGFwKChpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUpID0+IGl0ZW0ub25FbnRlcihncmlkc3RlcikpXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb2JzZXJ2YWJsZSB0aGF0IGlzIGZpcmVkIG9uIGRyYWcgb3V0IGdyaWRzdGVyIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZURyYWdPdXRPYnNlcnZhYmxlIChcbiAgICAgICAgZHJhZ0lzT3ZlcjogT2JzZXJ2YWJsZTx7aXRlbTogR3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlLFxuICAgICAgICBpc092ZXI6IGJvb2xlYW59PixcbiAgICAgICAgZ3JpZHN0ZXI6IEdyaWRzdGVyU2VydmljZVxuICAgICkge1xuICAgICAgICByZXR1cm4gZHJhZ0lzT3Zlci5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKChkYXRhOiBhbnkpID0+IGRhdGEuaXNPdXQpLFxuICAgICAgICAgICAgbWFwKChkYXRhOiBhbnkpOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUgPT4gZGF0YS5pdGVtKSxcbiAgICAgICAgICAgIHRhcCgoaXRlbTogR3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlKSA9PiBpdGVtLm9uT3V0KGdyaWRzdGVyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBcImVsZW1lbnRcIiBwb3NpdGlvbiBmaXRzIGluc2lkZSBcImNvbnRhaW5lckVsXCIgcG9zaXRpb24uXG4gICAgICogSXQgY2hlY2tzIGlmIFwiZWxlbWVudFwiIGlzIHRvdGFsbHkgY292ZXJlZCBieSBcImNvbnRhaW5lckVsXCIgYXJlYS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGlzT3ZlckdyaWRzdGVyKGl0ZW06IEdyaWRzdGVySXRlbVByb3RvdHlwZURpcmVjdGl2ZSwgZ3JpZHN0ZXJFbDogSFRNTEVsZW1lbnQsIGV2ZW50OiBhbnksIG9wdGlvbnM6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBlbCA9IGl0ZW0uJGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSA8SFRNTEVsZW1lbnQ+Z3JpZHN0ZXJFbC5wYXJlbnRFbGVtZW50ICYmXG4gICAgICAgICAgICA8SFRNTEVsZW1lbnQ+Z3JpZHN0ZXJFbC5wYXJlbnRFbGVtZW50LmNsb3Nlc3QoJ2dyaWRzdGVyLWl0ZW0nKTtcblxuICAgICAgICBpZiAocGFyZW50SXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPdmVyR3JpZHN0ZXIoaXRlbSwgcGFyZW50SXRlbSwgZXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnRvbGVyYW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnZml0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuaXNFbGVtZW50Rml0Q29udGFpbmVyKGVsLCBncmlkc3RlckVsKTtcbiAgICAgICAgICAgIGNhc2UgJ2ludGVyc2VjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmlzRWxlbWVudEludGVyc2VjdENvbnRhaW5lcihlbCwgZ3JpZHN0ZXJFbCk7XG4gICAgICAgICAgICBjYXNlICd0b3VjaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmlzRWxlbWVudFRvdWNoQ29udGFpbmVyKGVsLCBncmlkc3RlckVsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmlzQ3Vyc29yQWJvdmVFbGVtZW50KGV2ZW50LCBncmlkc3RlckVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==